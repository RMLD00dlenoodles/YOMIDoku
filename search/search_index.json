{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to YOMIDoku The unofficial Your Only Move Is Hustle source code documentation site.","title":"Home"},{"location":"about/","text":".spacer { padding-top: 10px; padding-bottom: 25px; } About YOMIDoku FAQ Q. What is the purpose of this website? To provide a well organized source of documentation for YOMI Hustle's source code, in order to ease the development of modifications for the game. Q. What version of YOMI Hustle does this site document? Currently the site documents version 0.6.0 of YOMI Hustle, but we intend to support documentation for several versions of YOMI Hustle's source code! Q. Will the site do anything else? Yes! This site will provide documentation for an example character in the future, which is intended to help newer modders. Q. Why is there \"N/A\" in some documents / Why is the site incomplete? Currently, this site is only maintained by one individual, soon to be a few; \"N/A\" means Not Available, and is used as a placeholder in lieu of information that the site authors do not have. We intend to fill out much more information as time goes on, please be patient with us! Q. How can I help develop the site? I'm glad you want to help out! Feel free to view the style guide, and format your documentation's information according to that; then, send your documentation over to D00dlenoodles. Contact Information D00dlenoodles: Site developer Discord: D00dlenoodles!#7546 E-Mail: rml.d00dlenoodles@gmail.com Attributions xColdxFusionx: Contributor","title":"About"},{"location":"about/#faq","text":"Q. What is the purpose of this website? To provide a well organized source of documentation for YOMI Hustle's source code, in order to ease the development of modifications for the game. Q. What version of YOMI Hustle does this site document? Currently the site documents version 0.6.0 of YOMI Hustle, but we intend to support documentation for several versions of YOMI Hustle's source code! Q. Will the site do anything else? Yes! This site will provide documentation for an example character in the future, which is intended to help newer modders. Q. Why is there \"N/A\" in some documents / Why is the site incomplete? Currently, this site is only maintained by one individual, soon to be a few; \"N/A\" means Not Available, and is used as a placeholder in lieu of information that the site authors do not have. We intend to fill out much more information as time goes on, please be patient with us! Q. How can I help develop the site? I'm glad you want to help out! Feel free to view the style guide, and format your documentation's information according to that; then, send your documentation over to D00dlenoodles.","title":"FAQ"},{"location":"about/#contact-information","text":"D00dlenoodles: Site developer Discord: D00dlenoodles!#7546 E-Mail: rml.d00dlenoodles@gmail.com","title":"Contact Information"},{"location":"about/#attributions","text":"xColdxFusionx: Contributor","title":"Attributions"},{"location":"Documentation/BaseChar/","text":".spacer { padding-top: 10px; padding-bottom: 25px; } .nowrap { overflow: hidden; white-space: nowrap; } BaseChar.md In: res://characters/BaseChar.gd Inherits: BaseObj Description Defines the Fighter class from which every YOMI Hustle character inherits. Contains properties that determine character metadata and variables that are useful as accessors. Properties Property Default Value Description MAX_HEALTH 1000 The health of your fighter. Enumerations There are no enumerated types for this class. Constants Constant Value Description MAX_STALES 15 N/A MIN_STALE_MODIFIER \"0.2\" N/A Methods init(pos = null) Init function Serves to handle fighter properties when lobby options are changed; i.e. if one hit K.O. is enabled. returns null Signals signal action_selected(action, data) N/A Credits Info contributed by D00dlenoodles Source BaseChar.gd extends BaseObj class_name Fighter signal action_selected ( action , data ) signal super_started () signal parried () signal undo () signal forfeit () var MAX_HEALTH = 1000 const MAX_STALES = 15 const MIN_STALE_MODIFIER = \"0.2\" const DAMAGE_SUPER_GAIN_DIVISOR = 1 const DAMAGE_TAKEN_SUPER_GAIN_DIVISOR = 3 const HITLAG_COLLISION_TICKS = 4 const PROJECTILE_PERFECT_PARRY_WINDOW = 3 const BURST_ON_DAMAGE_AMOUNT = 5 const COUNTER_HIT_ADDITIONAL_HITLAG_FRAMES = 3 const MAX_GROUNDED_HITS = 7 const PARRY_CHIP_DIVISOR = 3 const PARRY_KNOCKBACK_DIVISOR = \"3\" const P1_COLOR = Color ( \"aca2ff\" ) const P2_COLOR = Color ( \"ff7a81\" ) const GUTS_REDUCTIONS = { \"1\" : \"1\" , \"0.70\" : \"0.90\" , \"0.60\" : \"0.80\" , \"0.50\" : \"0.70\" , \"0.40\" : \"0.60\" , \"0.30\" : \"0.55\" , \"0.20\" : \"0.52\" , \"0.10\" : \"0.50\" , } const MAX_GUTS = 10 const MAX_DI_COMBO_ENHANCMENT = 15 const MAX_BURSTS = 1 const BURST_BUILD_SPEED = 4 const MAX_BURST_METER = 1500 const START_BURSTS = 1 const MAX_SUPER_METER = 125 const MAX_SUPERS = 9 const VEL_SUPER_GAIN_DIVISOR = 4 const NUDGE_DISTANCE = 20 const PARRY_METER = 50 const METER_GAIN_MODIFIER = \"1.0\" export var num_air_movements = 2 export ( Texture ) var character_portrait onready var you_label = $ YouLabel onready var actionable_label = $ ActionableLabel onready var quitter_label = $ \"%QuitterLabel\" var input_state = InputState . new () var color = Color . white export ( PackedScene ) var player_info_scene export ( PackedScene ) var player_extra_params_scene export var damage_taken_modifier = \"1.0\" export var num_feints = 2 var opponent var queued_action = null var queued_data = null var queued_extra = null var dummy_interruptable = false var game_over = false var forfeit = false var will_forfeit = false var applied_style = null var is_color_active = false var is_aura_active = false var is_style_active = null var ivy_effect = false var colliding_with_opponent = true var air_movements_left = 0 var action_cancels = { } var ghost_ready_tick = null var ghost_ready_set = false var got_parried = false var di_enabled = true var turbo_mode = false var infinite_resources = false var one_hit_ko = false var burst_enabled = true var always_perfect_parry = false var blocked_last_hit = false var trail_hp : int = MAX_HEALTH var hp : int = 0 var super_meter : int = 0 var supers_available : int = 0 var combo_proration : int = 0 var parried_last_state = false var initiative_effect = false var burst_meter : int = 0 var bursts_available : int = 0 var busy_interrupt = false var any_available_actions = true var state_changed = false var on_the_ground = false var nudge_amount = \"1.0\" var feints = 2 var current_nudge = { \"x\" : \"0\" , \"y\" : \"0\" , } var current_di = { \"x\" : \"0\" , \"y\" : \"0\" , } var last_vel = { \"x\" : \"0\" , \"y\" : \"0\" , } var last_aerial_vel = { \"x\" : \"0\" , \"y\" : \"0\" , } var combo_moves_used = {} var reverse_state = false var ghost_reverse = false var nudge_distance_left = 0 var can_nudge = false var parried = false var initiative = false var aura_particle = null var feinting = false var last_action = 0 var stance = \"Normal\" var parried_hitboxes = [] var grounded_hits_taken = 0 var throw_pos_x = 16 var throw_pos_y = - 5 var combo_damage = 0 var hitlag_applied = 0 var forfeit_ticks = 0 var lowest_tick = 0 class InputState : var name var data func init ( pos = null ): . init ( pos ) if not is_ghost : Network . player_objects [ id ] = self feints = num_feints if one_hit_ko : MAX_HEALTH = 1 hp = MAX_HEALTH game_over = false show_you_label () if burst_enabled : for i in range ( START_BURSTS ): gain_burst () for state in state_machine . get_children (): if state is CharacterState : for category in state . interrupt_from : if not action_cancels . has ( category ): action_cancels [ category ] = [] if not ( state in action_cancels [ category ]): action_cancels [ category ] . append ( state ) if infinite_resources : supers_available = MAX_SUPERS super_meter = MAX_SUPER_METER func apply_style ( style ): if not SteamYomi . STARTED : return if style != null and not is_ghost : is_color_active = true is_style_active = true applied_style = style if Global . enable_custom_colors and style . has ( \"character_color\" ) and style . character_color != null : set_color ( style . character_color ) Custom . apply_style_to_material ( style , sprite . get_material ()) if Global . enable_custom_particles and not is_ghost and style . show_aura and style . has ( \"aura_settings\" ): reset_aura () is_aura_active = true aura_particle = preload ( \"res://fx/CustomTrailParticle.tscn\" ) . instance () particles . add_child ( aura_particle ) aura_particle . load_settings ( style . aura_settings ) aura_particle . position = hurtbox_pos_float () aura_particle . start_emitting () if aura_particle . show_behind_parent : aura_particle . z_index = - 1 if style . has ( \"hitspark\" ): custom_hitspark = load ( Custom . hitsparks [ style . hitspark ]) for hitbox in hitboxes : hitbox . HIT_PARTICLE = custom_hitspark func reset_color (): is_color_active = false sprite . get_material () . set_shader_param ( \"color\" , P1_COLOR if id == 1 else P2_COLOR ) sprite . get_material () . set_shader_param ( \"use_outline\" , false ) func reset_aura (): is_aura_active = false if is_instance_valid ( aura_particle ): aura_particle . queue_free () aura_particle = null func reset_style (): reset_color () reset_aura () is_style_active = false func reapply_style (): apply_style ( applied_style ) func start_super (): emit_signal ( \"super_started\" ) func change_stance_to ( stance ): self . stance = stance func show_you_label (): if is_you (): you_label . show () func is_you (): if Network . multiplayer_active : return id == Network . player_id return false func _ready (): sprite . animation = \"Wait\" state_variables . append_array ( [ \"current_di\" , \"current_nudge\" , \"feinting\" , \"feints\" , \"lowest_tick\" , \"is_color_active\" , \"blocked_last_hit\" , \"combo_proration\" , \"state_changed\" , \"nudge_amount\" , \"initiative_effect\" , \"reverse_state\" , \"combo_moves_used\" , \"parried_last_state\" , \"initiative\" , \"last_vel\" , \"last_aerial_vel\" , \"trail_hp\" , \"always_perfect_parry\" , \"parried\" , \"got_parried\" , \"parried_this_frame\" , \"grounded_hits_taken\" , \"on_the_ground\" , \"hitlag_applied\" , \"combo_damage\" , \"burst_enabled\" , \"di_enabled\" , \"turbo_mode\" , \"infinite_resources\" , \"one_hit_ko\" , \"dummy_interruptable\" , \"air_movements_left\" , \"super_meter\" , \"supers_available\" , \"parried\" , \"parried_hitboxes\" , \"burst_meter\" , \"bursts_available\" ] ) add_to_group ( \"Fighter\" ) connect ( \"got_hit\" , self , \"on_got_hit\" ) state_machine . connect ( \"state_changed\" , self , \"on_state_changed\" ) func on_state_changed ( states_stack ): pass func on_got_hit (): pass func gain_burst_meter ( amount = null ): if not burst_enabled : return if bursts_available < MAX_BURSTS : burst_meter += BURST_BUILD_SPEED if amount == null else amount if burst_meter > MAX_BURST_METER : gain_burst () func copy_to ( f ): . copy_to ( f ) f . update_data () f . set_facing ( get_facing_int (), true ) f . update_data () func gain_burst (): if bursts_available < MAX_BURSTS : bursts_available += 1 burst_meter = 0 func use_burst (): if infinite_resources : return bursts_available -= 1 refresh_air_movements () func use_burst_meter ( amount ): if infinite_resources : return if bursts_available > 0 : bursts_available = 0 burst_meter = MAX_BURST_METER burst_meter -= amount func use_super_bar (): if infinite_resources : return supers_available -= 1 if supers_available < 0 : supers_available = 0 super_meter = 0 func use_super_meter ( amount ): if infinite_resources : return super_meter -= amount if super_meter < 0 : if supers_available > 0 : super_meter = MAX_SUPER_METER + super_meter use_super_bar () else : super_meter = 0 func stack_move_in_combo ( move_name ): if combo_moves_used . has ( move_name ): combo_moves_used [ move_name ] += 1 else : combo_moves_used [ move_name ] = 1 func gain_super_meter ( amount ): amount = combo_stale_meter ( amount ) super_meter += amount if super_meter >= MAX_SUPER_METER : if supers_available < MAX_SUPERS : super_meter -= MAX_SUPER_METER supers_available += 1 else : super_meter = MAX_SUPER_METER func combo_stale_meter ( meter : int ): var staling = get_combo_stale ( combo_count ) return fixed . round ( fixed . mul ( fixed . mul ( str ( meter ), staling ), METER_GAIN_MODIFIER )) func update_data (): data = get_data () obj_data = data [ \"object_data\" ] data [ \"state_data\" ] = { \"state\" : current_state () . state_name , \"frame\" : current_state () . current_tick , \"combo count\" : combo_count , } func get_playback_input (): if ReplayManager . playback : if get_frames () . has ( current_tick ): return get_frames ()[ current_tick ] func get_global_throw_pos (): var pos = get_pos () pos . x += throw_pos_x * get_facing_int () pos . y += throw_pos_y return pos func reset_combo (): combo_count = 0 combo_damage = 0 combo_proration = 0 combo_moves_used = {} opponent . grounded_hits_taken = 0 opponent . trail_hp = opponent . hp func incr_combo (): combo_count += 1 func is_colliding_with_opponent (): return ( colliding_with_opponent or ( current_state () is CharacterHurtState and ( hitlag_applied - hitlag_ticks ) < HITLAG_COLLISION_TICKS ) and current_state () . state_name != \"Grabbed\" ) func thrown_by ( hitbox : ThrowBox ): emit_signal ( \"got_hit\" ) state_machine . _change_state ( \"Grabbed\" ) func hitbox_from_name ( hitbox_name ): var hitbox_props = hitbox_name . split ( \"_\" ) var obj_name = hitbox_props [ 0 ] var hitbox_id = int ( hitbox_props [ - 1 ]) var obj = objs_map [ obj_name ] if obj : return objs_map [ obj_name ] . hitboxes [ hitbox_id ] func _process ( _delta ): update () if invulnerable : if ( Global . current_game . real_tick / 1 ) % 2 == 0 : var transparent = color self_modulate . a = 0.5 else : self_modulate . a = 1.0 else : self_modulate . a = 1.0 if is_instance_valid ( aura_particle ): aura_particle . visible = Global . enable_custom_particles aura_particle . position = hurtbox_pos_float () aura_particle . facing = get_facing_int () if is_style_active : if applied_style and not is_color_active and Global . enable_custom_colors : apply_style ( applied_style ) if applied_style and not is_aura_active and Global . enable_custom_particles : apply_style ( applied_style ) if is_color_active and not Global . enable_custom_colors : reset_color () if is_aura_active and not Global . enable_custom_particles : reset_aura () func debug_text (): . debug_text () debug_info ( { \"lowest_tick\" : lowest_tick , \"initiative\" : initiative , } ) func has_armor (): return false func launched_by ( hitbox ): hitlag_ticks = hitbox . victim_hitlag + ( COUNTER_HIT_ADDITIONAL_HITLAG_FRAMES if hitbox . counter_hit else 0 ) hitlag_applied = hitlag_ticks if objs_map . has ( hitbox . host ): var host = objs_map [ hitbox . host ] if host . hitlag_ticks < hitbox . hitlag_ticks : host . hitlag_ticks = hitbox . hitlag_ticks if hitbox . rumble : rumble ( hitbox . screenshake_amount , hitbox . victim_hitlag if hitbox . screenshake_frames < 0 else hitbox . screenshake_frames ) nudge_amount = hitbox . sdi_modifier if hitbox . ignore_armor or not has_armor (): var state if is_grounded (): state = hitbox . grounded_hit_state else : state = hitbox . aerial_hit_state if state == \"HurtGrounded\" : grounded_hits_taken += 1 if grounded_hits_taken >= MAX_GROUNDED_HITS : state = \"HurtAerial\" grounded_hits_taken = 0 state_machine . _change_state ( state , { \"hitbox\" : hitbox }) if hitbox . disable_collision : colliding_with_opponent = false busy_interrupt = true can_nudge = true if opponent . combo_count == 0 : opponent . combo_proration = hitbox . damage_proration var host = objs_map [ hitbox . host ] var projectile = not host . is_in_group ( \"Fighter\" ) if not projectile : refresh_feints () opponent . refresh_feints () if hitbox . increment_combo : opponent . incr_combo () emit_signal ( \"got_hit\" ) take_damage ( hitbox . damage , hitbox . minimum_damage ) state_tick () func hit_by ( hitbox ): if parried : return if hitbox . name in parried_hitboxes : return if not hitbox . hits_otg and is_otg (): return if hitbox . throw and not is_otg (): return thrown_by ( hitbox ) if not can_parry_hitbox ( hitbox ): match hitbox . hitbox_type : Hitbox . HitboxType . Normal : launched_by ( hitbox ) Hitbox . HitboxType . Flip : set_facing ( get_facing_int () * - 1 , true ) var vel = get_vel () set_vel ( fixed . mul ( vel . x , \"-1\" ), vel . y ) for hitbox in hitboxes : hitbox . facing = get_facing () pass emit_signal ( \"got_hit\" ) take_damage ( hitbox . damage , hitbox . minimum_damage ) Hitbox . HitboxType . ThrowHit : emit_signal ( \"got_hit\" ) take_damage ( hitbox . damage , hitbox . minimum_damage ) opponent . incr_combo () else : opponent . got_parried = true var host = objs_map [ hitbox . host ] var projectile = not host . is_in_group ( \"Fighter\" ) var perfect_parry if not projectile : perfect_parry = always_perfect_parry or opponent . current_state () . feinting or opponent . feinting or ( initiative and not blocked_last_hit ) or parried_last_state opponent . feinting = false opponent . current_state () . feinting = false else : perfect_parry = always_perfect_parry or parried_last_state or ( current_state () . current_tick < PROJECTILE_PERFECT_PARRY_WINDOW and host . has_projectile_parry_window ) if perfect_parry : parried_last_state = true else : blocked_last_hit = true parried = true hitlag_ticks = 0 parried_hitboxes . append ( hitbox . name ) var particle_location = current_state () . get ( \"particle_location\" ) particle_location . x *= get_facing_int () if not particle_location : particle_location = hitbox . get_overlap_center_float ( hurtbox ) var parry_meter = PARRY_METER if hitbox . parry_meter_gain == - 1 else hitbox . parry_meter_gain current_state () . parry ( perfect_parry ) if not perfect_parry : take_damage ( hitbox . damage / PARRY_CHIP_DIVISOR ) apply_force_relative ( fixed . div ( hitbox . knockback , fixed . mul ( PARRY_KNOCKBACK_DIVISOR , \"-1\" )), \"0\" ) gain_super_meter ( parry_meter / 3 ) opponent . gain_super_meter ( parry_meter / 3 ) if not projectile : current_state () . anim_length = opponent . current_state () . anim_length current_state () . endless = opponent . current_state () . endless current_state () . iasa_at = opponent . current_state () . iasa_at spawn_particle_effect ( preload ( \"res://fx/FlawedParryEffect.tscn\" ), get_pos_visual () + particle_location ) parried = false play_sound ( \"Block\" ) play_sound ( \"Parry\" ) else : spawn_particle_effect ( preload ( \"res://fx/ParryEffect.tscn\" ), get_pos_visual () + particle_location ) gain_super_meter ( parry_meter ) play_sound ( \"Parry2\" ) play_sound ( \"Parry\" ) emit_signal ( \"parried\" ) func set_throw_position ( x : int , y : int ): throw_pos_x = x throw_pos_y = y func take_damage ( damage : int , minimum = 0 ): if opponent . combo_count == 0 : trail_hp = hp if damage == 0 : return gain_burst_meter ( damage / BURST_ON_DAMAGE_AMOUNT ) damage = Utils . int_max ( guts_stale_damage ( combo_stale_damage ( damage )), 1 ) damage = Utils . int_max ( damage , minimum ) hp -= damage opponent . combo_damage += damage opponent . gain_super_meter ( damage / DAMAGE_SUPER_GAIN_DIVISOR ) gain_super_meter ( damage / DAMAGE_TAKEN_SUPER_GAIN_DIVISOR ) if hp < 0 : hp = 0 func get_guts (): var current_guts = \"1\" for level in GUTS_REDUCTIONS : var hp_level = fixed . div ( str ( hp ), str ( MAX_HEALTH )) if fixed . le ( hp_level , level ): current_guts = GUTS_REDUCTIONS [ level ] return current_guts func get_combo_stale ( count ): var ratio = fixed . div ( fixed . sub ( str ( MAX_STALES ), str ( Utils . int_min ( count , MAX_STALES ))), str ( MAX_STALES )) var mod = fixed . mul ( fixed . sub ( \"1\" , MIN_STALE_MODIFIER ), fixed . powu ( ratio , 2 )) mod = fixed . add ( mod , MIN_STALE_MODIFIER ) return mod func guts_stale_damage ( damage : int ): var guts = get_guts () damage = fixed . round ( fixed . mul ( str ( damage ), guts )) return damage func combo_stale_damage ( damage : int ): var staling = get_combo_stale ( Utils . int_max ( opponent . combo_count + ( opponent . combo_proration if opponent . combo_count > 1 else 0 ) - 1 , 0 )) return fixed . round ( fixed . mul ( str ( damage ), staling )) func can_parry_hitbox ( hitbox ): if not current_state () is ParryState : return false if hitbox . hitbox_type == Hitbox . HitboxType . Flip : return false return current_state () . can_parry_hitbox ( hitbox ) func set_color ( color : Color ): if color != null : sprite . get_material () . set_shader_param ( \"color\" , color ) self . color = color func release_opponent (): if opponent . current_state () . state_name == \"Grabbed\" : opponent . change_state ( \"Fall\" ) func process_extra ( extra ): if \"DI\" in extra : if di_enabled : var di = extra [ \"DI\" ] current_nudge = xy_to_dir ( di . x , di . y , str ( NUDGE_DISTANCE )) current_di = xy_to_dir ( di . x , di . y , fixed . add ( \"1.0\" , fixed . mul ( \"1.0\" , fixed . div ( str ( Utils . int_min ( MAX_DI_COMBO_ENHANCMENT , opponent . combo_count )), \"5\" )))) else : current_di = FixedVec2String . new ( 0 , 0 ) if \"reverse\" in extra : reverse_state = extra [ \"reverse\" ] if reverse_state : ghost_reverse = true if \"feint\" in extra : feinting = extra . feint if feinting : feints -= 1 else : feinting = false func refresh_air_movements (): air_movements_left = num_air_movements func refresh_feints (): feints = num_feints func clean_parried_hitboxes (): if not parried_hitboxes : return var hitboxes_to_refresh = [] for hitbox_name in parried_hitboxes : var hitbox = hitbox_from_name ( hitbox_name ) if hitbox : if not hitbox . enabled or not hitbox . active : hitboxes_to_refresh . append ( hitbox ) for hitbox in hitboxes_to_refresh : parried_hitboxes . erase ( hitbox . name ) func get_opponent_dir (): return Utils . int_sign ( opponent . get_pos () . x - get_pos () . x ) func get_advantage (): if opponent == null : return true var minus_modifier = 0 var advantage = ( opponent and opponent . lowest_tick <= lowest_tick ) or parried_last_state if state_interruptable and opponent . state_interruptable : advantage = true if current_state () . state_name == \"WhiffInstantCancel\" or ( previous_state () and previous_state () . state_name == \"WhiffInstantCancel\" and current_state () . has_hitboxes ): advantage = false if opponent . current_state () . state_name == \"WhiffInstantCancel\" or ( opponent . previous_state () and opponent . previous_state () . state_name == \"WhiffInstantCancel\" and opponent . current_state () . has_hitboxes ): advantage = false return advantage func set_lowest_tick ( tick ): if lowest_tick == null or tick < lowest_tick : lowest_tick = tick func update_advantage (): var new_adv = get_advantage () if new_adv and not initiative : initiative_effect = true initiative = new_adv func tick_before (): if queued_action == \"Forfeit\" : if forfeit : queued_action = \"Continue\" dummy_interruptable = false clean_parried_hitboxes () busy_interrupt = false update_grounded () if ReplayManager . playback : var input = get_playback_input () if input : queued_action = input [ \"action\" ] queued_data = input [ \"data\" ] queued_extra = input [ \"extra\" ] if queued_action == \"Forfeit\" : forfeit = true Global . current_game . forfeit ( id ) else : if queued_action : if queued_action == \"Undo\" : queued_action = null queued_data = null return if queued_action == \"Forfeit\" : forfeit = true if not is_ghost : ReplayManager . frames [ id ][ current_tick ] = { \"action\" : queued_action , \"data\" : queued_data , \"extra\" : queued_extra , } var feinted_last = feinting var pressed_feint = false if queued_extra : process_extra ( queued_extra ) pressed_feint = feinting if queued_action : if queued_action in state_machine . states_map : if feinted_last : var particle_pos = get_hurtbox_center_float () spawn_particle_effect ( preload ( \"res://fx/FeintEffect.tscn\" ), particle_pos ) state_machine . _change_state ( queued_action , queued_data ) if pressed_feint : feinting = true current_state () . feinting = true queued_action = null queued_data = null queued_extra = null lowest_tick = current_state () . current_real_tick func toggle_quit_graphic ( on = null ): if on == null : quitter_label . visible = not quitter_label . visible if quitter_label . visible : play_sound ( \"QuitterSound\" ) else : quitter_label . visible = on if on : play_sound ( \"QuitterSound\" ) func tick (): if hitlag_ticks > 0 : if can_nudge : if fixed . round ( fixed . mul ( fixed . vec_len ( current_nudge . x , current_nudge . y ), \"100.0\" )) > 1 : current_nudge = fixed . vec_mul ( current_nudge . x , current_nudge . y , nudge_amount ) spawn_particle_effect ( preload ( \"res://fx/NudgeIndicator.tscn\" ), Vector2 ( get_pos () . x , get_pos () . y + hurtbox . y ), Vector2 ( current_di . x , current_di . y ) . normalized ()) move_directly ( current_nudge . x , current_nudge . y if not is_grounded () else \"0\" ) can_nudge = false hitlag_ticks -= 1 if hitlag_ticks == 0 : if state_hit_cancellable : state_interruptable = true can_nudge = false else : if parried : parried = false if current_state () . get ( \"parry_active\" ): current_state () . parry_active = false var prev = previous_state () if prev and prev . get ( \"parry_active\" ): prev . parry_active = false var minus_offset = 0 if id == 1 else 1 state_tick () if state_hit_cancellable : state_interruptable = true can_nudge = false if not current_state () is ThrowState : chara . apply_pushback ( get_opponent_dir ()) if is_grounded (): refresh_air_movements () current_tick += 1 if not ( current_state () . is_hurt_state ) and not ( opponent . current_state () . is_hurt_state ): var x_vel_int = chara . get_x_vel_int () if Utils . int_sign ( x_vel_int ) == Utils . int_sign ( opponent . get_pos () . x - get_pos () . x ): gain_super_meter ( Utils . int_max ( Utils . int_abs ( x_vel_int ) / VEL_SUPER_GAIN_DIVISOR , 1 )) if state_interruptable : update_grounded () gain_burst_meter () update_data () for particle in particles . get_children (): particle . tick () any_available_actions = true last_vel = get_vel () if not is_grounded (): last_aerial_vel = last_vel if not ( previous_state () is ParryState ) or not ( current_state () is ParryState ): parried_last_state = false if forfeit : forfeit_ticks += 1 if forfeit and forfeit_ticks > 2 : change_state ( \"ForfeitExplosion\" ) forfeit = false func set_ghost_colors (): if not ghost_ready_set and ( state_interruptable or dummy_interruptable ): ghost_ready_set = true ghost_ready_tick = current_tick if opponent . ghost_ready_tick == null or opponent . ghost_ready_tick == ghost_ready_tick : set_color ( Color . green ) if opponent . current_state () . interruptible_on_opponent_turn or opponent . feinting : opponent . ghost_ready_set = true opponent . set_color ( Color . green ) elif opponent . ghost_ready_tick < ghost_ready_tick : set_color ( Color . orange ) func set_facing ( facing : int , force = false ): if reverse_state and not force : facing *= - 1 . set_facing ( facing ) func update_facing (): if obj_data . position_x < opponent . obj_data . position_x : set_facing ( 1 ) elif obj_data . position_x > opponent . obj_data . position_x : set_facing ( - 1 ) if initialized : update_data () func on_state_interruptable ( state ): if not dummy : state_interruptable = true else : dummy_interruptable = true func on_state_hit_cancellable ( state ): if not dummy : state_hit_cancellable = true func on_action_selected ( action , data , extra ): if you_label . visible : you_label . hide () queued_action = action queued_data = data queued_extra = extra state_interruptable = false state_hit_cancellable = false if action == \"Undo\" : emit_signal ( \"undo\" ) emit_signal ( \"action_selected\" , action , data , extra ) func forfeit (): will_forfeit = true func _draw (): pass","title":"Fighter"},{"location":"Documentation/BaseChar/#basecharmd","text":"In: res://characters/BaseChar.gd Inherits: BaseObj","title":"BaseChar.md"},{"location":"Documentation/BaseChar/#description","text":"Defines the Fighter class from which every YOMI Hustle character inherits. Contains properties that determine character metadata and variables that are useful as accessors.","title":"Description"},{"location":"Documentation/BaseChar/#properties","text":"Property Default Value Description MAX_HEALTH 1000 The health of your fighter.","title":"Properties"},{"location":"Documentation/BaseChar/#enumerations","text":"There are no enumerated types for this class.","title":"Enumerations"},{"location":"Documentation/BaseChar/#constants","text":"Constant Value Description MAX_STALES 15 N/A MIN_STALE_MODIFIER \"0.2\" N/A","title":"Constants"},{"location":"Documentation/BaseChar/#methods","text":"init(pos = null) Init function Serves to handle fighter properties when lobby options are changed; i.e. if one hit K.O. is enabled. returns null","title":"Methods"},{"location":"Documentation/BaseChar/#signals","text":"signal action_selected(action, data) N/A","title":"Signals"},{"location":"Documentation/BaseChar/#credits","text":"Info contributed by D00dlenoodles","title":"Credits"},{"location":"Documentation/BaseChar/#source","text":"BaseChar.gd extends BaseObj class_name Fighter signal action_selected ( action , data ) signal super_started () signal parried () signal undo () signal forfeit () var MAX_HEALTH = 1000 const MAX_STALES = 15 const MIN_STALE_MODIFIER = \"0.2\" const DAMAGE_SUPER_GAIN_DIVISOR = 1 const DAMAGE_TAKEN_SUPER_GAIN_DIVISOR = 3 const HITLAG_COLLISION_TICKS = 4 const PROJECTILE_PERFECT_PARRY_WINDOW = 3 const BURST_ON_DAMAGE_AMOUNT = 5 const COUNTER_HIT_ADDITIONAL_HITLAG_FRAMES = 3 const MAX_GROUNDED_HITS = 7 const PARRY_CHIP_DIVISOR = 3 const PARRY_KNOCKBACK_DIVISOR = \"3\" const P1_COLOR = Color ( \"aca2ff\" ) const P2_COLOR = Color ( \"ff7a81\" ) const GUTS_REDUCTIONS = { \"1\" : \"1\" , \"0.70\" : \"0.90\" , \"0.60\" : \"0.80\" , \"0.50\" : \"0.70\" , \"0.40\" : \"0.60\" , \"0.30\" : \"0.55\" , \"0.20\" : \"0.52\" , \"0.10\" : \"0.50\" , } const MAX_GUTS = 10 const MAX_DI_COMBO_ENHANCMENT = 15 const MAX_BURSTS = 1 const BURST_BUILD_SPEED = 4 const MAX_BURST_METER = 1500 const START_BURSTS = 1 const MAX_SUPER_METER = 125 const MAX_SUPERS = 9 const VEL_SUPER_GAIN_DIVISOR = 4 const NUDGE_DISTANCE = 20 const PARRY_METER = 50 const METER_GAIN_MODIFIER = \"1.0\" export var num_air_movements = 2 export ( Texture ) var character_portrait onready var you_label = $ YouLabel onready var actionable_label = $ ActionableLabel onready var quitter_label = $ \"%QuitterLabel\" var input_state = InputState . new () var color = Color . white export ( PackedScene ) var player_info_scene export ( PackedScene ) var player_extra_params_scene export var damage_taken_modifier = \"1.0\" export var num_feints = 2 var opponent var queued_action = null var queued_data = null var queued_extra = null var dummy_interruptable = false var game_over = false var forfeit = false var will_forfeit = false var applied_style = null var is_color_active = false var is_aura_active = false var is_style_active = null var ivy_effect = false var colliding_with_opponent = true var air_movements_left = 0 var action_cancels = { } var ghost_ready_tick = null var ghost_ready_set = false var got_parried = false var di_enabled = true var turbo_mode = false var infinite_resources = false var one_hit_ko = false var burst_enabled = true var always_perfect_parry = false var blocked_last_hit = false var trail_hp : int = MAX_HEALTH var hp : int = 0 var super_meter : int = 0 var supers_available : int = 0 var combo_proration : int = 0 var parried_last_state = false var initiative_effect = false var burst_meter : int = 0 var bursts_available : int = 0 var busy_interrupt = false var any_available_actions = true var state_changed = false var on_the_ground = false var nudge_amount = \"1.0\" var feints = 2 var current_nudge = { \"x\" : \"0\" , \"y\" : \"0\" , } var current_di = { \"x\" : \"0\" , \"y\" : \"0\" , } var last_vel = { \"x\" : \"0\" , \"y\" : \"0\" , } var last_aerial_vel = { \"x\" : \"0\" , \"y\" : \"0\" , } var combo_moves_used = {} var reverse_state = false var ghost_reverse = false var nudge_distance_left = 0 var can_nudge = false var parried = false var initiative = false var aura_particle = null var feinting = false var last_action = 0 var stance = \"Normal\" var parried_hitboxes = [] var grounded_hits_taken = 0 var throw_pos_x = 16 var throw_pos_y = - 5 var combo_damage = 0 var hitlag_applied = 0 var forfeit_ticks = 0 var lowest_tick = 0 class InputState : var name var data func init ( pos = null ): . init ( pos ) if not is_ghost : Network . player_objects [ id ] = self feints = num_feints if one_hit_ko : MAX_HEALTH = 1 hp = MAX_HEALTH game_over = false show_you_label () if burst_enabled : for i in range ( START_BURSTS ): gain_burst () for state in state_machine . get_children (): if state is CharacterState : for category in state . interrupt_from : if not action_cancels . has ( category ): action_cancels [ category ] = [] if not ( state in action_cancels [ category ]): action_cancels [ category ] . append ( state ) if infinite_resources : supers_available = MAX_SUPERS super_meter = MAX_SUPER_METER func apply_style ( style ): if not SteamYomi . STARTED : return if style != null and not is_ghost : is_color_active = true is_style_active = true applied_style = style if Global . enable_custom_colors and style . has ( \"character_color\" ) and style . character_color != null : set_color ( style . character_color ) Custom . apply_style_to_material ( style , sprite . get_material ()) if Global . enable_custom_particles and not is_ghost and style . show_aura and style . has ( \"aura_settings\" ): reset_aura () is_aura_active = true aura_particle = preload ( \"res://fx/CustomTrailParticle.tscn\" ) . instance () particles . add_child ( aura_particle ) aura_particle . load_settings ( style . aura_settings ) aura_particle . position = hurtbox_pos_float () aura_particle . start_emitting () if aura_particle . show_behind_parent : aura_particle . z_index = - 1 if style . has ( \"hitspark\" ): custom_hitspark = load ( Custom . hitsparks [ style . hitspark ]) for hitbox in hitboxes : hitbox . HIT_PARTICLE = custom_hitspark func reset_color (): is_color_active = false sprite . get_material () . set_shader_param ( \"color\" , P1_COLOR if id == 1 else P2_COLOR ) sprite . get_material () . set_shader_param ( \"use_outline\" , false ) func reset_aura (): is_aura_active = false if is_instance_valid ( aura_particle ): aura_particle . queue_free () aura_particle = null func reset_style (): reset_color () reset_aura () is_style_active = false func reapply_style (): apply_style ( applied_style ) func start_super (): emit_signal ( \"super_started\" ) func change_stance_to ( stance ): self . stance = stance func show_you_label (): if is_you (): you_label . show () func is_you (): if Network . multiplayer_active : return id == Network . player_id return false func _ready (): sprite . animation = \"Wait\" state_variables . append_array ( [ \"current_di\" , \"current_nudge\" , \"feinting\" , \"feints\" , \"lowest_tick\" , \"is_color_active\" , \"blocked_last_hit\" , \"combo_proration\" , \"state_changed\" , \"nudge_amount\" , \"initiative_effect\" , \"reverse_state\" , \"combo_moves_used\" , \"parried_last_state\" , \"initiative\" , \"last_vel\" , \"last_aerial_vel\" , \"trail_hp\" , \"always_perfect_parry\" , \"parried\" , \"got_parried\" , \"parried_this_frame\" , \"grounded_hits_taken\" , \"on_the_ground\" , \"hitlag_applied\" , \"combo_damage\" , \"burst_enabled\" , \"di_enabled\" , \"turbo_mode\" , \"infinite_resources\" , \"one_hit_ko\" , \"dummy_interruptable\" , \"air_movements_left\" , \"super_meter\" , \"supers_available\" , \"parried\" , \"parried_hitboxes\" , \"burst_meter\" , \"bursts_available\" ] ) add_to_group ( \"Fighter\" ) connect ( \"got_hit\" , self , \"on_got_hit\" ) state_machine . connect ( \"state_changed\" , self , \"on_state_changed\" ) func on_state_changed ( states_stack ): pass func on_got_hit (): pass func gain_burst_meter ( amount = null ): if not burst_enabled : return if bursts_available < MAX_BURSTS : burst_meter += BURST_BUILD_SPEED if amount == null else amount if burst_meter > MAX_BURST_METER : gain_burst () func copy_to ( f ): . copy_to ( f ) f . update_data () f . set_facing ( get_facing_int (), true ) f . update_data () func gain_burst (): if bursts_available < MAX_BURSTS : bursts_available += 1 burst_meter = 0 func use_burst (): if infinite_resources : return bursts_available -= 1 refresh_air_movements () func use_burst_meter ( amount ): if infinite_resources : return if bursts_available > 0 : bursts_available = 0 burst_meter = MAX_BURST_METER burst_meter -= amount func use_super_bar (): if infinite_resources : return supers_available -= 1 if supers_available < 0 : supers_available = 0 super_meter = 0 func use_super_meter ( amount ): if infinite_resources : return super_meter -= amount if super_meter < 0 : if supers_available > 0 : super_meter = MAX_SUPER_METER + super_meter use_super_bar () else : super_meter = 0 func stack_move_in_combo ( move_name ): if combo_moves_used . has ( move_name ): combo_moves_used [ move_name ] += 1 else : combo_moves_used [ move_name ] = 1 func gain_super_meter ( amount ): amount = combo_stale_meter ( amount ) super_meter += amount if super_meter >= MAX_SUPER_METER : if supers_available < MAX_SUPERS : super_meter -= MAX_SUPER_METER supers_available += 1 else : super_meter = MAX_SUPER_METER func combo_stale_meter ( meter : int ): var staling = get_combo_stale ( combo_count ) return fixed . round ( fixed . mul ( fixed . mul ( str ( meter ), staling ), METER_GAIN_MODIFIER )) func update_data (): data = get_data () obj_data = data [ \"object_data\" ] data [ \"state_data\" ] = { \"state\" : current_state () . state_name , \"frame\" : current_state () . current_tick , \"combo count\" : combo_count , } func get_playback_input (): if ReplayManager . playback : if get_frames () . has ( current_tick ): return get_frames ()[ current_tick ] func get_global_throw_pos (): var pos = get_pos () pos . x += throw_pos_x * get_facing_int () pos . y += throw_pos_y return pos func reset_combo (): combo_count = 0 combo_damage = 0 combo_proration = 0 combo_moves_used = {} opponent . grounded_hits_taken = 0 opponent . trail_hp = opponent . hp func incr_combo (): combo_count += 1 func is_colliding_with_opponent (): return ( colliding_with_opponent or ( current_state () is CharacterHurtState and ( hitlag_applied - hitlag_ticks ) < HITLAG_COLLISION_TICKS ) and current_state () . state_name != \"Grabbed\" ) func thrown_by ( hitbox : ThrowBox ): emit_signal ( \"got_hit\" ) state_machine . _change_state ( \"Grabbed\" ) func hitbox_from_name ( hitbox_name ): var hitbox_props = hitbox_name . split ( \"_\" ) var obj_name = hitbox_props [ 0 ] var hitbox_id = int ( hitbox_props [ - 1 ]) var obj = objs_map [ obj_name ] if obj : return objs_map [ obj_name ] . hitboxes [ hitbox_id ] func _process ( _delta ): update () if invulnerable : if ( Global . current_game . real_tick / 1 ) % 2 == 0 : var transparent = color self_modulate . a = 0.5 else : self_modulate . a = 1.0 else : self_modulate . a = 1.0 if is_instance_valid ( aura_particle ): aura_particle . visible = Global . enable_custom_particles aura_particle . position = hurtbox_pos_float () aura_particle . facing = get_facing_int () if is_style_active : if applied_style and not is_color_active and Global . enable_custom_colors : apply_style ( applied_style ) if applied_style and not is_aura_active and Global . enable_custom_particles : apply_style ( applied_style ) if is_color_active and not Global . enable_custom_colors : reset_color () if is_aura_active and not Global . enable_custom_particles : reset_aura () func debug_text (): . debug_text () debug_info ( { \"lowest_tick\" : lowest_tick , \"initiative\" : initiative , } ) func has_armor (): return false func launched_by ( hitbox ): hitlag_ticks = hitbox . victim_hitlag + ( COUNTER_HIT_ADDITIONAL_HITLAG_FRAMES if hitbox . counter_hit else 0 ) hitlag_applied = hitlag_ticks if objs_map . has ( hitbox . host ): var host = objs_map [ hitbox . host ] if host . hitlag_ticks < hitbox . hitlag_ticks : host . hitlag_ticks = hitbox . hitlag_ticks if hitbox . rumble : rumble ( hitbox . screenshake_amount , hitbox . victim_hitlag if hitbox . screenshake_frames < 0 else hitbox . screenshake_frames ) nudge_amount = hitbox . sdi_modifier if hitbox . ignore_armor or not has_armor (): var state if is_grounded (): state = hitbox . grounded_hit_state else : state = hitbox . aerial_hit_state if state == \"HurtGrounded\" : grounded_hits_taken += 1 if grounded_hits_taken >= MAX_GROUNDED_HITS : state = \"HurtAerial\" grounded_hits_taken = 0 state_machine . _change_state ( state , { \"hitbox\" : hitbox }) if hitbox . disable_collision : colliding_with_opponent = false busy_interrupt = true can_nudge = true if opponent . combo_count == 0 : opponent . combo_proration = hitbox . damage_proration var host = objs_map [ hitbox . host ] var projectile = not host . is_in_group ( \"Fighter\" ) if not projectile : refresh_feints () opponent . refresh_feints () if hitbox . increment_combo : opponent . incr_combo () emit_signal ( \"got_hit\" ) take_damage ( hitbox . damage , hitbox . minimum_damage ) state_tick () func hit_by ( hitbox ): if parried : return if hitbox . name in parried_hitboxes : return if not hitbox . hits_otg and is_otg (): return if hitbox . throw and not is_otg (): return thrown_by ( hitbox ) if not can_parry_hitbox ( hitbox ): match hitbox . hitbox_type : Hitbox . HitboxType . Normal : launched_by ( hitbox ) Hitbox . HitboxType . Flip : set_facing ( get_facing_int () * - 1 , true ) var vel = get_vel () set_vel ( fixed . mul ( vel . x , \"-1\" ), vel . y ) for hitbox in hitboxes : hitbox . facing = get_facing () pass emit_signal ( \"got_hit\" ) take_damage ( hitbox . damage , hitbox . minimum_damage ) Hitbox . HitboxType . ThrowHit : emit_signal ( \"got_hit\" ) take_damage ( hitbox . damage , hitbox . minimum_damage ) opponent . incr_combo () else : opponent . got_parried = true var host = objs_map [ hitbox . host ] var projectile = not host . is_in_group ( \"Fighter\" ) var perfect_parry if not projectile : perfect_parry = always_perfect_parry or opponent . current_state () . feinting or opponent . feinting or ( initiative and not blocked_last_hit ) or parried_last_state opponent . feinting = false opponent . current_state () . feinting = false else : perfect_parry = always_perfect_parry or parried_last_state or ( current_state () . current_tick < PROJECTILE_PERFECT_PARRY_WINDOW and host . has_projectile_parry_window ) if perfect_parry : parried_last_state = true else : blocked_last_hit = true parried = true hitlag_ticks = 0 parried_hitboxes . append ( hitbox . name ) var particle_location = current_state () . get ( \"particle_location\" ) particle_location . x *= get_facing_int () if not particle_location : particle_location = hitbox . get_overlap_center_float ( hurtbox ) var parry_meter = PARRY_METER if hitbox . parry_meter_gain == - 1 else hitbox . parry_meter_gain current_state () . parry ( perfect_parry ) if not perfect_parry : take_damage ( hitbox . damage / PARRY_CHIP_DIVISOR ) apply_force_relative ( fixed . div ( hitbox . knockback , fixed . mul ( PARRY_KNOCKBACK_DIVISOR , \"-1\" )), \"0\" ) gain_super_meter ( parry_meter / 3 ) opponent . gain_super_meter ( parry_meter / 3 ) if not projectile : current_state () . anim_length = opponent . current_state () . anim_length current_state () . endless = opponent . current_state () . endless current_state () . iasa_at = opponent . current_state () . iasa_at spawn_particle_effect ( preload ( \"res://fx/FlawedParryEffect.tscn\" ), get_pos_visual () + particle_location ) parried = false play_sound ( \"Block\" ) play_sound ( \"Parry\" ) else : spawn_particle_effect ( preload ( \"res://fx/ParryEffect.tscn\" ), get_pos_visual () + particle_location ) gain_super_meter ( parry_meter ) play_sound ( \"Parry2\" ) play_sound ( \"Parry\" ) emit_signal ( \"parried\" ) func set_throw_position ( x : int , y : int ): throw_pos_x = x throw_pos_y = y func take_damage ( damage : int , minimum = 0 ): if opponent . combo_count == 0 : trail_hp = hp if damage == 0 : return gain_burst_meter ( damage / BURST_ON_DAMAGE_AMOUNT ) damage = Utils . int_max ( guts_stale_damage ( combo_stale_damage ( damage )), 1 ) damage = Utils . int_max ( damage , minimum ) hp -= damage opponent . combo_damage += damage opponent . gain_super_meter ( damage / DAMAGE_SUPER_GAIN_DIVISOR ) gain_super_meter ( damage / DAMAGE_TAKEN_SUPER_GAIN_DIVISOR ) if hp < 0 : hp = 0 func get_guts (): var current_guts = \"1\" for level in GUTS_REDUCTIONS : var hp_level = fixed . div ( str ( hp ), str ( MAX_HEALTH )) if fixed . le ( hp_level , level ): current_guts = GUTS_REDUCTIONS [ level ] return current_guts func get_combo_stale ( count ): var ratio = fixed . div ( fixed . sub ( str ( MAX_STALES ), str ( Utils . int_min ( count , MAX_STALES ))), str ( MAX_STALES )) var mod = fixed . mul ( fixed . sub ( \"1\" , MIN_STALE_MODIFIER ), fixed . powu ( ratio , 2 )) mod = fixed . add ( mod , MIN_STALE_MODIFIER ) return mod func guts_stale_damage ( damage : int ): var guts = get_guts () damage = fixed . round ( fixed . mul ( str ( damage ), guts )) return damage func combo_stale_damage ( damage : int ): var staling = get_combo_stale ( Utils . int_max ( opponent . combo_count + ( opponent . combo_proration if opponent . combo_count > 1 else 0 ) - 1 , 0 )) return fixed . round ( fixed . mul ( str ( damage ), staling )) func can_parry_hitbox ( hitbox ): if not current_state () is ParryState : return false if hitbox . hitbox_type == Hitbox . HitboxType . Flip : return false return current_state () . can_parry_hitbox ( hitbox ) func set_color ( color : Color ): if color != null : sprite . get_material () . set_shader_param ( \"color\" , color ) self . color = color func release_opponent (): if opponent . current_state () . state_name == \"Grabbed\" : opponent . change_state ( \"Fall\" ) func process_extra ( extra ): if \"DI\" in extra : if di_enabled : var di = extra [ \"DI\" ] current_nudge = xy_to_dir ( di . x , di . y , str ( NUDGE_DISTANCE )) current_di = xy_to_dir ( di . x , di . y , fixed . add ( \"1.0\" , fixed . mul ( \"1.0\" , fixed . div ( str ( Utils . int_min ( MAX_DI_COMBO_ENHANCMENT , opponent . combo_count )), \"5\" )))) else : current_di = FixedVec2String . new ( 0 , 0 ) if \"reverse\" in extra : reverse_state = extra [ \"reverse\" ] if reverse_state : ghost_reverse = true if \"feint\" in extra : feinting = extra . feint if feinting : feints -= 1 else : feinting = false func refresh_air_movements (): air_movements_left = num_air_movements func refresh_feints (): feints = num_feints func clean_parried_hitboxes (): if not parried_hitboxes : return var hitboxes_to_refresh = [] for hitbox_name in parried_hitboxes : var hitbox = hitbox_from_name ( hitbox_name ) if hitbox : if not hitbox . enabled or not hitbox . active : hitboxes_to_refresh . append ( hitbox ) for hitbox in hitboxes_to_refresh : parried_hitboxes . erase ( hitbox . name ) func get_opponent_dir (): return Utils . int_sign ( opponent . get_pos () . x - get_pos () . x ) func get_advantage (): if opponent == null : return true var minus_modifier = 0 var advantage = ( opponent and opponent . lowest_tick <= lowest_tick ) or parried_last_state if state_interruptable and opponent . state_interruptable : advantage = true if current_state () . state_name == \"WhiffInstantCancel\" or ( previous_state () and previous_state () . state_name == \"WhiffInstantCancel\" and current_state () . has_hitboxes ): advantage = false if opponent . current_state () . state_name == \"WhiffInstantCancel\" or ( opponent . previous_state () and opponent . previous_state () . state_name == \"WhiffInstantCancel\" and opponent . current_state () . has_hitboxes ): advantage = false return advantage func set_lowest_tick ( tick ): if lowest_tick == null or tick < lowest_tick : lowest_tick = tick func update_advantage (): var new_adv = get_advantage () if new_adv and not initiative : initiative_effect = true initiative = new_adv func tick_before (): if queued_action == \"Forfeit\" : if forfeit : queued_action = \"Continue\" dummy_interruptable = false clean_parried_hitboxes () busy_interrupt = false update_grounded () if ReplayManager . playback : var input = get_playback_input () if input : queued_action = input [ \"action\" ] queued_data = input [ \"data\" ] queued_extra = input [ \"extra\" ] if queued_action == \"Forfeit\" : forfeit = true Global . current_game . forfeit ( id ) else : if queued_action : if queued_action == \"Undo\" : queued_action = null queued_data = null return if queued_action == \"Forfeit\" : forfeit = true if not is_ghost : ReplayManager . frames [ id ][ current_tick ] = { \"action\" : queued_action , \"data\" : queued_data , \"extra\" : queued_extra , } var feinted_last = feinting var pressed_feint = false if queued_extra : process_extra ( queued_extra ) pressed_feint = feinting if queued_action : if queued_action in state_machine . states_map : if feinted_last : var particle_pos = get_hurtbox_center_float () spawn_particle_effect ( preload ( \"res://fx/FeintEffect.tscn\" ), particle_pos ) state_machine . _change_state ( queued_action , queued_data ) if pressed_feint : feinting = true current_state () . feinting = true queued_action = null queued_data = null queued_extra = null lowest_tick = current_state () . current_real_tick func toggle_quit_graphic ( on = null ): if on == null : quitter_label . visible = not quitter_label . visible if quitter_label . visible : play_sound ( \"QuitterSound\" ) else : quitter_label . visible = on if on : play_sound ( \"QuitterSound\" ) func tick (): if hitlag_ticks > 0 : if can_nudge : if fixed . round ( fixed . mul ( fixed . vec_len ( current_nudge . x , current_nudge . y ), \"100.0\" )) > 1 : current_nudge = fixed . vec_mul ( current_nudge . x , current_nudge . y , nudge_amount ) spawn_particle_effect ( preload ( \"res://fx/NudgeIndicator.tscn\" ), Vector2 ( get_pos () . x , get_pos () . y + hurtbox . y ), Vector2 ( current_di . x , current_di . y ) . normalized ()) move_directly ( current_nudge . x , current_nudge . y if not is_grounded () else \"0\" ) can_nudge = false hitlag_ticks -= 1 if hitlag_ticks == 0 : if state_hit_cancellable : state_interruptable = true can_nudge = false else : if parried : parried = false if current_state () . get ( \"parry_active\" ): current_state () . parry_active = false var prev = previous_state () if prev and prev . get ( \"parry_active\" ): prev . parry_active = false var minus_offset = 0 if id == 1 else 1 state_tick () if state_hit_cancellable : state_interruptable = true can_nudge = false if not current_state () is ThrowState : chara . apply_pushback ( get_opponent_dir ()) if is_grounded (): refresh_air_movements () current_tick += 1 if not ( current_state () . is_hurt_state ) and not ( opponent . current_state () . is_hurt_state ): var x_vel_int = chara . get_x_vel_int () if Utils . int_sign ( x_vel_int ) == Utils . int_sign ( opponent . get_pos () . x - get_pos () . x ): gain_super_meter ( Utils . int_max ( Utils . int_abs ( x_vel_int ) / VEL_SUPER_GAIN_DIVISOR , 1 )) if state_interruptable : update_grounded () gain_burst_meter () update_data () for particle in particles . get_children (): particle . tick () any_available_actions = true last_vel = get_vel () if not is_grounded (): last_aerial_vel = last_vel if not ( previous_state () is ParryState ) or not ( current_state () is ParryState ): parried_last_state = false if forfeit : forfeit_ticks += 1 if forfeit and forfeit_ticks > 2 : change_state ( \"ForfeitExplosion\" ) forfeit = false func set_ghost_colors (): if not ghost_ready_set and ( state_interruptable or dummy_interruptable ): ghost_ready_set = true ghost_ready_tick = current_tick if opponent . ghost_ready_tick == null or opponent . ghost_ready_tick == ghost_ready_tick : set_color ( Color . green ) if opponent . current_state () . interruptible_on_opponent_turn or opponent . feinting : opponent . ghost_ready_set = true opponent . set_color ( Color . green ) elif opponent . ghost_ready_tick < ghost_ready_tick : set_color ( Color . orange ) func set_facing ( facing : int , force = false ): if reverse_state and not force : facing *= - 1 . set_facing ( facing ) func update_facing (): if obj_data . position_x < opponent . obj_data . position_x : set_facing ( 1 ) elif obj_data . position_x > opponent . obj_data . position_x : set_facing ( - 1 ) if initialized : update_data () func on_state_interruptable ( state ): if not dummy : state_interruptable = true else : dummy_interruptable = true func on_state_hit_cancellable ( state ): if not dummy : state_hit_cancellable = true func on_action_selected ( action , data , extra ): if you_label . visible : you_label . hide () queued_action = action queued_data = data queued_extra = extra state_interruptable = false state_hit_cancellable = false if action == \"Undo\" : emit_signal ( \"undo\" ) emit_signal ( \"action_selected\" , action , data , extra ) func forfeit (): will_forfeit = true func _draw (): pass","title":"Source"},{"location":"Documentation/BaseProjectile/","text":".spacer { padding-top: 10px; padding-bottom: 25px; } .nowrap { overflow: hidden; white-space: nowrap; } BaseProjectile In: res://projectile/BaseProjectile.gd Inherits: BaseObj > BaseProjectile Description Base class used for projectiles. This file mostly defines properties to be used by projectile state scripts, such as DefaultFireball. Properties Property Default Value Description immunity_susceptible true N/A deletes_other_projectiles true Whether or not the projectile deletes other projectiles that collide with it. Enumerations There are no enumerated types for this class. Constants There are no constants for this class. Methods disable() Removes the projectile from play. Note that this doesn't actually delete the projectile, but disables the sprite, hitboxes, and particles, rendering the projectile invisible and unable to interact with other objects. returns null Signals There are no signals for this class. Credits Info contributed by xColdxFusionx Source BaseProjectile.gd extends BaseObj class_name BaseProjectile export var immunity_susceptible = true export var deletes_other_projectiles = true func disable (): sprite . hide () disabled = true for hitbox in get_active_hitboxes (): hitbox . deactivate () stop_particles ()","title":"BaseProjectile"},{"location":"Documentation/BaseProjectile/#baseprojectile","text":"In: res://projectile/BaseProjectile.gd Inherits: BaseObj > BaseProjectile","title":"BaseProjectile"},{"location":"Documentation/BaseProjectile/#description","text":"Base class used for projectiles. This file mostly defines properties to be used by projectile state scripts, such as DefaultFireball.","title":"Description"},{"location":"Documentation/BaseProjectile/#properties","text":"Property Default Value Description immunity_susceptible true N/A deletes_other_projectiles true Whether or not the projectile deletes other projectiles that collide with it.","title":"Properties"},{"location":"Documentation/BaseProjectile/#enumerations","text":"There are no enumerated types for this class.","title":"Enumerations"},{"location":"Documentation/BaseProjectile/#constants","text":"There are no constants for this class.","title":"Constants"},{"location":"Documentation/BaseProjectile/#methods","text":"disable() Removes the projectile from play. Note that this doesn't actually delete the projectile, but disables the sprite, hitboxes, and particles, rendering the projectile invisible and unable to interact with other objects. returns null","title":"Methods"},{"location":"Documentation/BaseProjectile/#signals","text":"There are no signals for this class.","title":"Signals"},{"location":"Documentation/BaseProjectile/#credits","text":"Info contributed by xColdxFusionx","title":"Credits"},{"location":"Documentation/BaseProjectile/#source","text":"BaseProjectile.gd extends BaseObj class_name BaseProjectile export var immunity_susceptible = true export var deletes_other_projectiles = true func disable (): sprite . hide () disabled = true for hitbox in get_active_hitboxes (): hitbox . deactivate () stop_particles ()","title":"Source"},{"location":"Documentation/DefaultFireball/","text":".spacer { padding-top: 10px; padding-bottom: 25px; } .nowrap { overflow: hidden; white-space: nowrap; } DefaultFireball In: res://characters/stickman/projectiles/fireball_states/Default.gd Inherits: StateInterface > ObjectState > DefaultFireball Description Default state for projectiles. Contains most of the projectile's processing code. Properties Property Default Value Description move_x 4 Base horizontal speed of the projectile. move_y 0 Base vertical speed of the projectile. clash true Whether or not the projectile reacts to collisions with other entities. num_hits 1 The number of hits the projectile can perform before disappearing. lifetime 999999 If the projectile has been alive for this many frames and has not been disabled, it will be disabled automatically. fizzle_on_ground true Whether or not the projectile fizzles upon hitting the ground. fizzle_on_walls true Whether or not the projectile fizzles upon hitting a wall. Enumerations There are no enumerated types for this class. Constants A list of constants, alongside a brief description and their values in the following format: Constant Value Description FREE_AFTER_TICKS 60 Unknown use, presumably for garbage collection. Methods _frame_0() Runs on the tick before the state begins. Initializes hit_something and hit_something_tick , and sets the host's is_grounded to false. returns null _tick() Runs each tick. If the projectile collides with a wall or the ground, run fizzle() . If the projectile has lived longer than its lifetime , run fizzle() . If the projectile has not hit anything, move the projectile, adding data[\"speed_modifier\"] if applicable. returns null _on_hit_something(obj, _hitbox) Runs upon colliding with an object. If clash is true, check if obj is a BaseProjectile. If it is and deletes other projectiles is false, do nothing. If clash is true and either of the additional checks fail, reduce num_hits by 1. If this reduces the value to 0, run fizzle() . returns null fizzle() Disables the host and terminates all hitboxes. Also sets hit_something to true and hit_something_tick to the current tick. returns null Signals There are no signals for this class. Credits Info contributed by xColdxFusionx Source Default.gd extends ObjectState class_name DefaultFireball const FREE_AFTER_TICKS = 60 export var _c_Projectile_Dir = 0 export var move_x = 4 export var move_y = 0 export var clash = true export var num_hits = 1 export var lifetime = 999999 export var fizzle_on_ground = true export var fizzle_on_walls = true var hit_something = false var hit_something_tick = 0 func _frame_0 (): hit_something = false hit_something_tick = 0 host . set_grounded ( false ) func _tick (): var pos = host . get_pos () host . update_grounded () if not hit_something and (( host . is_grounded () and fizzle_on_ground ) or ( fizzle_on_walls and ( pos . x < - host . stage_width or pos . x > host . stage_width ))): fizzle () host . hurtbox . width = 0 host . hurtbox . height = 0 pass if current_tick >= lifetime : fizzle () elif not hit_something : if data and data . has ( \"speed_modifier\" ): host . move_directly_relative (( move_x + data [ \"speed_modifier\" ]) if move_x != 0 else 0 , ( move_y + data [ \"speed_modifier\" ]) if move_y != 0 else 0 ) else : host . move_directly_relative ( move_x , move_y ) func _on_hit_something ( obj , _hitbox ): if clash : if obj is BaseProjectile : if not obj . deletes_other_projectiles : return num_hits -= 1 if num_hits == 0 : fizzle () func fizzle (): hit_something = true host . disable () terminate_hitboxes () hit_something_tick = current_tick","title":"DefaultFireball"},{"location":"Documentation/DefaultFireball/#defaultfireball","text":"In: res://characters/stickman/projectiles/fireball_states/Default.gd Inherits: StateInterface > ObjectState > DefaultFireball","title":"DefaultFireball"},{"location":"Documentation/DefaultFireball/#description","text":"Default state for projectiles. Contains most of the projectile's processing code.","title":"Description"},{"location":"Documentation/DefaultFireball/#properties","text":"Property Default Value Description move_x 4 Base horizontal speed of the projectile. move_y 0 Base vertical speed of the projectile. clash true Whether or not the projectile reacts to collisions with other entities. num_hits 1 The number of hits the projectile can perform before disappearing. lifetime 999999 If the projectile has been alive for this many frames and has not been disabled, it will be disabled automatically. fizzle_on_ground true Whether or not the projectile fizzles upon hitting the ground. fizzle_on_walls true Whether or not the projectile fizzles upon hitting a wall.","title":"Properties"},{"location":"Documentation/DefaultFireball/#enumerations","text":"There are no enumerated types for this class.","title":"Enumerations"},{"location":"Documentation/DefaultFireball/#constants","text":"A list of constants, alongside a brief description and their values in the following format: Constant Value Description FREE_AFTER_TICKS 60 Unknown use, presumably for garbage collection.","title":"Constants"},{"location":"Documentation/DefaultFireball/#methods","text":"_frame_0() Runs on the tick before the state begins. Initializes hit_something and hit_something_tick , and sets the host's is_grounded to false. returns null _tick() Runs each tick. If the projectile collides with a wall or the ground, run fizzle() . If the projectile has lived longer than its lifetime , run fizzle() . If the projectile has not hit anything, move the projectile, adding data[\"speed_modifier\"] if applicable. returns null _on_hit_something(obj, _hitbox) Runs upon colliding with an object. If clash is true, check if obj is a BaseProjectile. If it is and deletes other projectiles is false, do nothing. If clash is true and either of the additional checks fail, reduce num_hits by 1. If this reduces the value to 0, run fizzle() . returns null fizzle() Disables the host and terminates all hitboxes. Also sets hit_something to true and hit_something_tick to the current tick. returns null","title":"Methods"},{"location":"Documentation/DefaultFireball/#signals","text":"There are no signals for this class.","title":"Signals"},{"location":"Documentation/DefaultFireball/#credits","text":"Info contributed by xColdxFusionx","title":"Credits"},{"location":"Documentation/DefaultFireball/#source","text":"Default.gd extends ObjectState class_name DefaultFireball const FREE_AFTER_TICKS = 60 export var _c_Projectile_Dir = 0 export var move_x = 4 export var move_y = 0 export var clash = true export var num_hits = 1 export var lifetime = 999999 export var fizzle_on_ground = true export var fizzle_on_walls = true var hit_something = false var hit_something_tick = 0 func _frame_0 (): hit_something = false hit_something_tick = 0 host . set_grounded ( false ) func _tick (): var pos = host . get_pos () host . update_grounded () if not hit_something and (( host . is_grounded () and fizzle_on_ground ) or ( fizzle_on_walls and ( pos . x < - host . stage_width or pos . x > host . stage_width ))): fizzle () host . hurtbox . width = 0 host . hurtbox . height = 0 pass if current_tick >= lifetime : fizzle () elif not hit_something : if data and data . has ( \"speed_modifier\" ): host . move_directly_relative (( move_x + data [ \"speed_modifier\" ]) if move_x != 0 else 0 , ( move_y + data [ \"speed_modifier\" ]) if move_y != 0 else 0 ) else : host . move_directly_relative ( move_x , move_y ) func _on_hit_something ( obj , _hitbox ): if clash : if obj is BaseProjectile : if not obj . deletes_other_projectiles : return num_hits -= 1 if num_hits == 0 : fizzle () func fizzle (): hit_something = true host . disable () terminate_hitboxes () hit_something_tick = current_tick","title":"Source"},{"location":"Documentation/DirProjectileDefault/","text":".spacer { padding-top: 10px; padding-bottom: 25px; } .nowrap { overflow: hidden; white-space: nowrap; } DirProjectileDefault In: res://projectile/DirProjectileDefault.gd Inherits: StateInterface > ObjectState > DirProjectileDefault.gd (Note that this doesn't have a class name; extend from the file path instead.) Description Default projectile state for directional projectiles. Properties Property Default Value Description move_speed \"15.0\" How quickly the projectile should move. Used for non-homing projectiles. homing false Whether the projectile actively tracks opponents. homing_turn_speed \"3.0\" How quickly the projectile turns while tracking an opponent. homing_accel \"1.0\" How quickly the projectile accelerates when tracking an opponent. max_homing_speed \"10\" The projectile's maximum speed when tracking an opponent start_homing false Whether or not the projectile should be aimed based on data[\"dir\"] when starting this state. lifetime 999999 If the projectile has been in this state for longer than this number of ticks, it fizzles. Enumerations There are no enumerated types for this class. Constants Constant Value Description FREE_AFTER_TICKS 60 Unknown use, presumably for garbage collection. Methods _frame_1() Runs on the first tick of the state. Initializes hit_something and hit_something_tick , and sets the host's is_grounded to false. if homing is true, also sets initial velocity based on whether or not start_homing is also true. returns null _tick() Runs each tick. If the projectile collides with a wall or the ground, run fizzle() . If the projectile has lived longer than its lifetime , run fizzle() . If the projectile has not hit anything, check if the projectile is supposed to be homing or not. If not, move the projectile directly based on data[\"dir\"] ; if it is, calculate and apply a force to push it towards host.creator.opponent based on the parameters provided. returns null _got_parried() Called when a hitbox belonging to this state is parried. If homing is true, immediately calls fizzle() returns null . fizzle() Disables the host and terminates all hitboxes. Also sets hit_something to true and hit_something_tick to the current tick. returns null _on_hit_something(obj, _hitbox) Runs upon colliding with an object. Immediately calls fizzle() . returns null Signals There are no signals for this class. Credits Info contributed by xColdxFusionx Source DirProjectileDefault.gd extends ObjectState const FREE_AFTER_TICKS = 60 export var _c_Projectile_Dir = 0 export var move_speed = \"15.0\" export var _c_Homing_Options = 0 export var homing = false export var homing_turn_speed = \"3.0\" export var homing_accel = \"1.0\" export var max_homing_speed = \"10\" export var start_homing = false export var lifetime = 99999 export var relative_data_dir = false var hit_something = false var hit_something_tick = 0 func _frame_1 (): hit_something = false hit_something_tick = 0 host . set_grounded ( false ) if homing : if start_homing : var dir = data [ \"dir\" ] var move_vec = fixed . normalized_vec_times ( str ( dir . x ), str ( dir . y ), move_speed ) host . apply_force ( move_vec . x , move_vec . y ) else : host . apply_force_relative ( move_speed , \"0.01\" ) func _tick (): var pos = host . get_pos () host . update_grounded () if current_tick > 1 and not hit_something and host . is_grounded () or pos . x < - host . stage_width or pos . x > host . stage_width : fizzle () host . hurtbox . width = 0 host . hurtbox . height = 0 pass if current_tick > lifetime : fizzle () host . hurtbox . width = 0 host . hurtbox . height = 0 elif not hit_something : var dir if not homing : dir = data [ \"dir\" ] var dir_x = fixed . mul ( dir . x , str ( host . get_facing_int ())) if relative_data_dir else dir . x var move_vec = fixed . normalized_vec_times ( dir_x , str ( dir . y ), move_speed ) host . move_directly ( move_vec . x , move_vec . y ) host . sprite . rotation = float ( fixed . vec_to_angle ( dir . x , dir . y )) else : var target = host . obj_local_center ( host . creator . opponent ) var vel = host . get_vel () var current = fixed . normalized_vec ( vel . x , vel . y ) var desired = fixed . normalized_vec ( str ( target . x ), str ( target . y )) var steering_x = fixed . sub ( desired . x , current . x ) var steering_y = fixed . sub ( desired . y , current . y ) var steer_force = fixed . normalized_vec_times ( steering_x , steering_y , homing_turn_speed ) var force_x = fixed . mul ( current . x , homing_accel ) var force_y = fixed . mul ( current . y , homing_accel ) if not fixed . eq ( vel . x , \"0\" ): host . set_facing ( 1 if fixed . gt ( vel . x , \"0\" ) else - 1 ) host . apply_force ( force_x , force_y ) host . apply_force ( steer_force . x , steer_force . y ) host . apply_forces () host . update_data () var new_vel = host . get_vel () if fixed . gt ( fixed . vec_len ( new_vel . x , new_vel . y ), max_homing_speed ): var clamped_vel = fixed . normalized_vec_times ( new_vel . x , new_vel . y , max_homing_speed ) host . set_vel ( clamped_vel . x , clamped_vel . y ) host . sprite . rotation = float ( fixed . vec_to_angle ( fixed . mul ( new_vel . x , str ( host . get_facing_int ())), new_vel . y )) func _got_parried (): if homing : fizzle () func fizzle (): hit_something = true host . disable () terminate_hitboxes () hit_something_tick = current_tick func _on_hit_something ( _obj , _hitbox ): fizzle ()","title":"DirProjectileDefault"},{"location":"Documentation/DirProjectileDefault/#dirprojectiledefault","text":"In: res://projectile/DirProjectileDefault.gd Inherits: StateInterface > ObjectState > DirProjectileDefault.gd (Note that this doesn't have a class name; extend from the file path instead.)","title":"DirProjectileDefault"},{"location":"Documentation/DirProjectileDefault/#description","text":"Default projectile state for directional projectiles.","title":"Description"},{"location":"Documentation/DirProjectileDefault/#properties","text":"Property Default Value Description move_speed \"15.0\" How quickly the projectile should move. Used for non-homing projectiles. homing false Whether the projectile actively tracks opponents. homing_turn_speed \"3.0\" How quickly the projectile turns while tracking an opponent. homing_accel \"1.0\" How quickly the projectile accelerates when tracking an opponent. max_homing_speed \"10\" The projectile's maximum speed when tracking an opponent start_homing false Whether or not the projectile should be aimed based on data[\"dir\"] when starting this state. lifetime 999999 If the projectile has been in this state for longer than this number of ticks, it fizzles.","title":"Properties"},{"location":"Documentation/DirProjectileDefault/#enumerations","text":"There are no enumerated types for this class.","title":"Enumerations"},{"location":"Documentation/DirProjectileDefault/#constants","text":"Constant Value Description FREE_AFTER_TICKS 60 Unknown use, presumably for garbage collection.","title":"Constants"},{"location":"Documentation/DirProjectileDefault/#methods","text":"_frame_1() Runs on the first tick of the state. Initializes hit_something and hit_something_tick , and sets the host's is_grounded to false. if homing is true, also sets initial velocity based on whether or not start_homing is also true. returns null _tick() Runs each tick. If the projectile collides with a wall or the ground, run fizzle() . If the projectile has lived longer than its lifetime , run fizzle() . If the projectile has not hit anything, check if the projectile is supposed to be homing or not. If not, move the projectile directly based on data[\"dir\"] ; if it is, calculate and apply a force to push it towards host.creator.opponent based on the parameters provided. returns null _got_parried() Called when a hitbox belonging to this state is parried. If homing is true, immediately calls fizzle() returns null . fizzle() Disables the host and terminates all hitboxes. Also sets hit_something to true and hit_something_tick to the current tick. returns null _on_hit_something(obj, _hitbox) Runs upon colliding with an object. Immediately calls fizzle() . returns null","title":"Methods"},{"location":"Documentation/DirProjectileDefault/#signals","text":"There are no signals for this class.","title":"Signals"},{"location":"Documentation/DirProjectileDefault/#credits","text":"Info contributed by xColdxFusionx","title":"Credits"},{"location":"Documentation/DirProjectileDefault/#source","text":"DirProjectileDefault.gd extends ObjectState const FREE_AFTER_TICKS = 60 export var _c_Projectile_Dir = 0 export var move_speed = \"15.0\" export var _c_Homing_Options = 0 export var homing = false export var homing_turn_speed = \"3.0\" export var homing_accel = \"1.0\" export var max_homing_speed = \"10\" export var start_homing = false export var lifetime = 99999 export var relative_data_dir = false var hit_something = false var hit_something_tick = 0 func _frame_1 (): hit_something = false hit_something_tick = 0 host . set_grounded ( false ) if homing : if start_homing : var dir = data [ \"dir\" ] var move_vec = fixed . normalized_vec_times ( str ( dir . x ), str ( dir . y ), move_speed ) host . apply_force ( move_vec . x , move_vec . y ) else : host . apply_force_relative ( move_speed , \"0.01\" ) func _tick (): var pos = host . get_pos () host . update_grounded () if current_tick > 1 and not hit_something and host . is_grounded () or pos . x < - host . stage_width or pos . x > host . stage_width : fizzle () host . hurtbox . width = 0 host . hurtbox . height = 0 pass if current_tick > lifetime : fizzle () host . hurtbox . width = 0 host . hurtbox . height = 0 elif not hit_something : var dir if not homing : dir = data [ \"dir\" ] var dir_x = fixed . mul ( dir . x , str ( host . get_facing_int ())) if relative_data_dir else dir . x var move_vec = fixed . normalized_vec_times ( dir_x , str ( dir . y ), move_speed ) host . move_directly ( move_vec . x , move_vec . y ) host . sprite . rotation = float ( fixed . vec_to_angle ( dir . x , dir . y )) else : var target = host . obj_local_center ( host . creator . opponent ) var vel = host . get_vel () var current = fixed . normalized_vec ( vel . x , vel . y ) var desired = fixed . normalized_vec ( str ( target . x ), str ( target . y )) var steering_x = fixed . sub ( desired . x , current . x ) var steering_y = fixed . sub ( desired . y , current . y ) var steer_force = fixed . normalized_vec_times ( steering_x , steering_y , homing_turn_speed ) var force_x = fixed . mul ( current . x , homing_accel ) var force_y = fixed . mul ( current . y , homing_accel ) if not fixed . eq ( vel . x , \"0\" ): host . set_facing ( 1 if fixed . gt ( vel . x , \"0\" ) else - 1 ) host . apply_force ( force_x , force_y ) host . apply_force ( steer_force . x , steer_force . y ) host . apply_forces () host . update_data () var new_vel = host . get_vel () if fixed . gt ( fixed . vec_len ( new_vel . x , new_vel . y ), max_homing_speed ): var clamped_vel = fixed . normalized_vec_times ( new_vel . x , new_vel . y , max_homing_speed ) host . set_vel ( clamped_vel . x , clamped_vel . y ) host . sprite . rotation = float ( fixed . vec_to_angle ( fixed . mul ( new_vel . x , str ( host . get_facing_int ())), new_vel . y )) func _got_parried (): if homing : fizzle () func fizzle (): hit_something = true host . disable () terminate_hitboxes () hit_something_tick = current_tick func _on_hit_something ( _obj , _hitbox ): fizzle ()","title":"Source"},{"location":"Documentation/ObjectState/","text":".spacer { padding-top: 10px; padding-bottom: 25px; } .nowrap { overflow: hidden; white-space: nowrap; } ObjectState In: res://ObjectState.gd Inherits: StateInterface > ObjectState Description Base code for states. This applies to both player and projectile states. Properties Property Default Value Description apply_forces false Whether or not the state should calculate movement based on forces. apply_fric false Whether or not the state should account for friction when determining movement. apply_grav false Whether or not the state should account for gravity when determining movement. fallback_state \"Wait\" The state to move to automatically when this state ends. sprite_animation \"\" The animation to play for this state. anim_length 1 How many ticks this state lasts. sprite_anim_length -1 How many frames of the animation to use. (-1 defaults to the full animation) ticks_per_frame 1 How many ticks each frame of the animation should last. loop_animation false Whether or not the animation should loop, or freeze on the last frame. endless false If true, the object will not enter the fallback state once the animation ends. force_dir_x \"0.0\" The x component of the timed force's direction. force_dir_y \"0.0\" The y component of the timed force's direction. force_speed \"0.0\" The magnitude of the timed force. force_tick 0 The tick on which the timed force is performed. enter_force_dir_x \"0.0\" The x component of the entry force's direction. enter_force_dir_y \"0.0\" The y component of the entry force's direction. enter_force_speed \"0.0\" The magnitude of the entryforce. reset_momentum false Whether or not the object's momentum is reset upon entering this state. particle_scene null A scene (ParticleEffect) to be spawned when entering the state. particle_position Vector2() The position at which to spawn particle_scene . spawn_particle_on_enter false Whether or not the game should attempt to spawn particle_scene when entering the state. timed_particle_scene null A scene (intended to be ParticleEffect) to be spawned when entering the state. timed_particle_position Vector2() The position at which to spawn timed_particle_scene . timed_spawn_particle_tick 1 The tick on which to spawn timed_particle_scene , if applicable. enter_sfx null AudioStream to play when entering the state. enter_sfx_volume -15.0 Volume modifier for enter_sfx . sfx null AudioStream to play during the state. sfx_tick 1 What tick to play sfx during. sfx_volume -15.0 Volume modifier for sfx . projectile_scene N/A A scene (intended to be BaseProjectile) to be spawned during the state. projectile_tick 1 The tick on which to spawn projectile_scene . projectile_pos_x 0 The horizontal offset of the projectile. projectile_pos_y 0 The vertical offset of the projectile. projectile_local_pos true Whether or not the projectile's spawn location is an absolute or relative position. throw_positions {} Dictionary containing position vectors. Can be set using the CharStateEditor; used for complex throw animations. enter_sfx_player N/A VariableSound2D for playing enter_sfx . sfx_player N/A VariableSound2D for playing sfx . current_tick -1 Current tick of the state, as used for animation purposes. current_real_tick -1 Current tick of the state, ignoring animation looping. fixed N/A FixedMath for fixed-point calculations. anim_name N/A Name of the current animation. has_hitboxes false Whether or not the state has hitboxes. current_hurtbox null The user's current hurtbox. hitbox_start_frames {} Lists when the user's hitboxes activate, and which ones. hurtbox_state_change_frames {} Lists when the user's hurtbox changes, and to which ones. frame_methods [] List of frames with scripting tied to them. max_tick -1 Tracks the highest tick the state has reached. Enumerations There are no enumerated types for this class. Constants There are no constants for this class. Methods apply_enter_force() Applies a force based on the enter_force parameters. returns null _on_hit_something(obj, _hitbox) Called when a hitbox in this state collides with something. returns null get_projectile_pos() Returns a Dictionary containing the projectile's starting position. returns Dict get_projectile_data() Returns null by default. returns null process_projectile(_projectile) Does nothing by default. returns null get_active_hitboxes() Returns all active hitboxes in the state. returns array _tick_before() Processing performed at the beginnnig of each tick. Does nothing by default. returns null process_feint() Returns the fallback state by default. returns string _tick_shared() Shared per_tick processing for all states. Updates things such as hitboxes, hurtboxes, current_tick counters, and movement. Returns a string if the processing detects that the state needs to be updated; otherwise, returns nothing. returns string, null process_hitboxes() Activates and deactivates hitboxes based on the current tick. returns null update_hurtbox() Updates the hurtbox based on any HurtboxState nodes available. returns null _tick_after() Processing performed at the end of each tick. Updates hitbox positions based on the object's location. returns null copy_data() Creates a copy of the state's data and returns it. returns data copy_to(state:ObjectState) Copies the current state's properties to state 's properties. returns null activate_hitbox(hitbox) Calls hitbox.activate() . returns null terminate_hitboxes() Deactivates all hitboxes in the current state. returns null deactivate_hitbox(hitbox) Does nothing by default. returns null init() Performs initial setup for the state. returns null setup_audio() Sets up required parameters for playing sound effects. returns null setup_hitboxes() Sets up parameters for hitboxes. returns null setup_hurtboxes() Sets up parameters for hurtboxes. returns null __on_hit_something(obj, _hitbox) Called when detecting the signal \"hit_something\" from an attached hitbox. Calls _on_hit_something() . returns null __on_got_parried() Called when detecting the signal \"got_parried\" from an attached hitbox. Calls _got_parried() . returns null _got_parried() Does nothing by default. returns null spawn_particle_relative(scene:PackedScene, pos = Vector2(), dir = Vector2.RIGHT) Spawns a particle effect at the listed position and direction relative to the user. returns null _enter_shared() Shared processing upon entering the state. returns null _exit_shared() Shared processing upon exiting the state. Resets the current hurtbox. returns null xy_to_dir(x, y, mul=\"1.0\", div = \"100.0\") Passthrough function for converting an X and Y value to a movement vector, with optional modifiers for speed. Returns a Dictionary containing the results. returns Dict update_sprite_frame() Updates the currently displayed sprite frame to match the current tick. returns null Signals state_started() Emitted upon entering the state. state_ended() Emitted upon exiting the state. Credits Info contributed by xColdxFusionx Source ObjectState.gd extends StateInterface class_name ObjectState signal state_started () signal state_ended () export var _c_Physics = 0 export var apply_forces = false export var apply_fric = false export var apply_grav = false export var _c_Animation_and_Length = 0 export var fallback_state = \"Wait\" export var sprite_animation = \"\" export var anim_length = 1 export var sprite_anim_length = - 1 export var ticks_per_frame = 1 export var loop_animation = false export var endless = false export var _c_Static_Force = 0 export var force_dir_x = \"0.0\" export var force_dir_y = \"0.0\" export var force_speed = \"0.0\" export var force_tick = 0 export var _c_Enter_Static_Force = 0 export var enter_force_dir_x = \"0.0\" export var enter_force_dir_y = \"0.0\" export var enter_force_speed = \"0.0\" export var reset_momentum = false export var _c_Particles = 0 export ( PackedScene ) var particle_scene = null export var particle_position = Vector2 () export var spawn_particle_on_enter = false export var _c_TimedParticles = 0 export ( PackedScene ) var timed_particle_scene = null export var timed_particle_position = Vector2 () export var timed_spawn_particle_tick = 1 export var _c_Sfx = 0 export ( AudioStream ) var enter_sfx = null export var enter_sfx_volume = - 15.0 export ( AudioStream ) var sfx = null export var sfx_tick = 1 export var sfx_volume = - 15.0 export var _c_Projectiles = 0 export ( PackedScene ) var projectile_scene export var projectile_tick = 1 export var projectile_pos_x = 0 export var projectile_pos_y = 0 export var projectile_local_pos = true export var _c_Auto = 0 export var throw_positions : Dictionary = {} var enter_sfx_player var sfx_player var current_tick = - 1 var current_real_tick = - 1 var fixed var anim_name var has_hitboxes = false var current_hurtbox = null var hitbox_start_frames = { } var hurtbox_state_change_frames = { } var frame_methods = [] var max_tick = - 1 func apply_enter_force (): if enter_force_speed != \"0.0\" : var force = xy_to_dir ( enter_force_dir_x , enter_force_dir_y , enter_force_speed , \"1.0\" ) host . apply_force_relative ( force . x , force . y ) func _on_hit_something ( _obj , _hitbox ): pass func get_projectile_pos (): return { \"x\" : projectile_pos_x , \"y\" : projectile_pos_y } func get_projectile_data (): return null func process_projectile ( _projectile ): pass func get_active_hitboxes (): var hitboxes = [] for start_frame in hitbox_start_frames : var items = hitbox_start_frames [ start_frame ] for item in items : if item is Hitbox : hitboxes . append ( item ) return hitboxes func _tick_before (): pass func process_feint (): return fallback_state func _tick_shared (): if current_tick == - 1 : if spawn_particle_on_enter and particle_scene : var pos = particle_position pos . x *= host . get_facing_int () spawn_particle_relative ( particle_scene , pos , Vector2 . RIGHT * host . get_facing_int ()) apply_enter_force () current_real_tick += 1 if current_tick < anim_length or endless : current_tick += 1 process_hitboxes () update_sprite_frame () update_hurtbox () if current_tick == sfx_tick and sfx_player and not ReplayManager . resimulating : sfx_player . play () if current_tick == force_tick : if force_speed != \"0.0\" : var force = xy_to_dir ( force_dir_x , force_dir_y , force_speed , \"1.0\" ) host . apply_force_relative ( force . x , force . y ) if current_tick == projectile_tick : if projectile_scene : var pos = get_projectile_pos () var obj = host . spawn_object ( projectile_scene , pos . x , pos . y , true , get_projectile_data (), projectile_local_pos ) process_projectile ( obj ) if current_tick == timed_spawn_particle_tick : if timed_particle_scene : var pos = timed_particle_position pos . x *= host . get_facing_int () spawn_particle_relative ( timed_particle_scene , pos , Vector2 . RIGHT * host . get_facing_int ()) var new_max = false if current_tick > max_tick : max_tick = current_tick new_max = true if host . is_ghost or new_max or current_tick in frame_methods : var method_name = \"_frame_\" + str ( current_tick ) if has_method ( method_name ): if not ( current_tick in frame_methods ): frame_methods . append ( current_tick ) var next_state = call ( method_name ) if next_state != null : return next_state new_max = false if apply_fric : host . apply_fric () if apply_grav : host . apply_grav () if apply_forces : host . apply_forces () func process_hitboxes (): if hitbox_start_frames . has ( current_tick + 1 ): for hitbox in hitbox_start_frames [ current_tick + 1 ]: activate_hitbox ( hitbox ) for hitbox in get_active_hitboxes (): hitbox . facing = host . get_facing () if hitbox . active : hitbox . tick () else : deactivate_hitbox ( hitbox ) func update_hurtbox (): if current_hurtbox : current_hurtbox . tick ( host ) if current_tick in hurtbox_state_change_frames : if current_hurtbox : current_hurtbox . end ( host ) current_hurtbox = hurtbox_state_change_frames [ current_tick ] current_hurtbox . start ( host ) func _tick_after (): for hitbox in get_active_hitboxes (): var pos = host . get_pos () hitbox . update_position ( pos . x , pos . y ) func copy_data (): var d = null if data : if data is Dictionary or data is Array : d = data . duplicate () else : d = data return d func copy_to ( state : ObjectState ): var properties = get_script () . get_script_property_list () for variable in properties : var value = get ( variable . name ) if not ( value is Object or value is Array or value is Dictionary ): if value : state . set ( variable . name , value ) state . data = copy_data () state . current_real_tick = current_real_tick state . current_tick = current_real_tick func activate_hitbox ( hitbox ): hitbox . activate () func terminate_hitboxes (): for hitbox in get_active_hitboxes (): hitbox . deactivate () func deactivate_hitbox ( hitbox ): pass func init (): connect ( \"state_started\" , host , \"on_state_started\" , [ self ]) connect ( \"state_ended\" , host , \"on_state_ended\" , [ self ]) fixed = host . fixed anim_name = sprite_animation if sprite_animation else state_name if sprite_anim_length < 0 : if host . sprite . frames . has_animation ( anim_name ): sprite_anim_length = host . sprite . frames . get_frame_count ( anim_name ) else : sprite_anim_length = anim_length setup_hitboxes () setup_hurtboxes () call_deferred ( \"setup_audio\" ) func setup_audio (): if enter_sfx : enter_sfx_player = VariableSound2D . new () add_child ( enter_sfx_player ) enter_sfx_player . bus = \"Fx\" enter_sfx_player . stream = enter_sfx enter_sfx_player . volume_db = enter_sfx_volume if sfx : sfx_player = VariableSound2D . new () add_child ( sfx_player ) sfx_player . bus = \"Fx\" sfx_player . stream = sfx sfx_player . volume_db = sfx_volume func setup_hitboxes (): var hitboxes = [] for child in get_children (): if child is Hitbox : hitboxes . append ( child ) host . hitboxes . append ( child ) for hitbox in hitboxes : hitbox . init () has_hitboxes = true hitbox . host = host if hitbox . start_tick >= 0 : if hitbox_start_frames . has ( hitbox . start_tick ): hitbox_start_frames [ hitbox . start_tick ] . append ( hitbox ) else : hitbox_start_frames [ hitbox . start_tick ] = [ hitbox ] hitbox . connect ( \"hit_something\" , self , \"__on_hit_something\" ) hitbox . connect ( \"got_parried\" , self , \"__on_got_parried\" ) for hitbox2 in hitboxes : if hitbox2 . group == hitbox . group : hitbox . grouped_hitboxes . append ( hitbox2 ) func setup_hurtboxes (): for child in get_children (): if child is HurtboxState : hurtbox_state_change_frames [ child . start_tick ] = child func __on_hit_something ( obj , hitbox ): if active : _on_hit_something ( obj , hitbox ) func __on_got_parried (): if active : _got_parried () func _got_parried (): pass func spawn_particle_relative ( scene : PackedScene , pos = Vector2 (), dir = Vector2 . RIGHT ): var p = host . get_pos_visual () host . spawn_particle_effect ( scene , p + pos , dir ) func _enter_shared (): if reset_momentum : host . reset_momentum () current_tick = - 1 current_real_tick = - 1 if enter_sfx_player and not ReplayManager . resimulating : enter_sfx_player . play () emit_signal ( \"state_started\" ) func _exit_shared (): if current_hurtbox : current_hurtbox . end ( host ) host . reset_hurtbox () func xy_to_dir ( x , y , mul = \"1.0\" , div = \"100.0\" ): return host . xy_to_dir ( x , y , mul , div ) func update_sprite_frame (): if ReplayManager . resimulating : return if not host . sprite . frames . has_animation ( anim_name ): return if host . sprite . animation != anim_name : host . sprite . animation = anim_name host . sprite . frame = 0 var sprite_tick = current_tick / ticks_per_frame var frame = ( sprite_tick % sprite_anim_length ) if loop_animation else Utils . int_min ( sprite_tick , sprite_anim_length ) host . sprite . frame = frame","title":"ObjectState"},{"location":"Documentation/ObjectState/#objectstate","text":"In: res://ObjectState.gd Inherits: StateInterface > ObjectState","title":"ObjectState"},{"location":"Documentation/ObjectState/#description","text":"Base code for states. This applies to both player and projectile states.","title":"Description"},{"location":"Documentation/ObjectState/#properties","text":"Property Default Value Description apply_forces false Whether or not the state should calculate movement based on forces. apply_fric false Whether or not the state should account for friction when determining movement. apply_grav false Whether or not the state should account for gravity when determining movement. fallback_state \"Wait\" The state to move to automatically when this state ends. sprite_animation \"\" The animation to play for this state. anim_length 1 How many ticks this state lasts. sprite_anim_length -1 How many frames of the animation to use. (-1 defaults to the full animation) ticks_per_frame 1 How many ticks each frame of the animation should last. loop_animation false Whether or not the animation should loop, or freeze on the last frame. endless false If true, the object will not enter the fallback state once the animation ends. force_dir_x \"0.0\" The x component of the timed force's direction. force_dir_y \"0.0\" The y component of the timed force's direction. force_speed \"0.0\" The magnitude of the timed force. force_tick 0 The tick on which the timed force is performed. enter_force_dir_x \"0.0\" The x component of the entry force's direction. enter_force_dir_y \"0.0\" The y component of the entry force's direction. enter_force_speed \"0.0\" The magnitude of the entryforce. reset_momentum false Whether or not the object's momentum is reset upon entering this state. particle_scene null A scene (ParticleEffect) to be spawned when entering the state. particle_position Vector2() The position at which to spawn particle_scene . spawn_particle_on_enter false Whether or not the game should attempt to spawn particle_scene when entering the state. timed_particle_scene null A scene (intended to be ParticleEffect) to be spawned when entering the state. timed_particle_position Vector2() The position at which to spawn timed_particle_scene . timed_spawn_particle_tick 1 The tick on which to spawn timed_particle_scene , if applicable. enter_sfx null AudioStream to play when entering the state. enter_sfx_volume -15.0 Volume modifier for enter_sfx . sfx null AudioStream to play during the state. sfx_tick 1 What tick to play sfx during. sfx_volume -15.0 Volume modifier for sfx . projectile_scene N/A A scene (intended to be BaseProjectile) to be spawned during the state. projectile_tick 1 The tick on which to spawn projectile_scene . projectile_pos_x 0 The horizontal offset of the projectile. projectile_pos_y 0 The vertical offset of the projectile. projectile_local_pos true Whether or not the projectile's spawn location is an absolute or relative position. throw_positions {} Dictionary containing position vectors. Can be set using the CharStateEditor; used for complex throw animations. enter_sfx_player N/A VariableSound2D for playing enter_sfx . sfx_player N/A VariableSound2D for playing sfx . current_tick -1 Current tick of the state, as used for animation purposes. current_real_tick -1 Current tick of the state, ignoring animation looping. fixed N/A FixedMath for fixed-point calculations. anim_name N/A Name of the current animation. has_hitboxes false Whether or not the state has hitboxes. current_hurtbox null The user's current hurtbox. hitbox_start_frames {} Lists when the user's hitboxes activate, and which ones. hurtbox_state_change_frames {} Lists when the user's hurtbox changes, and to which ones. frame_methods [] List of frames with scripting tied to them. max_tick -1 Tracks the highest tick the state has reached.","title":"Properties"},{"location":"Documentation/ObjectState/#enumerations","text":"There are no enumerated types for this class.","title":"Enumerations"},{"location":"Documentation/ObjectState/#constants","text":"There are no constants for this class.","title":"Constants"},{"location":"Documentation/ObjectState/#methods","text":"apply_enter_force() Applies a force based on the enter_force parameters. returns null _on_hit_something(obj, _hitbox) Called when a hitbox in this state collides with something. returns null get_projectile_pos() Returns a Dictionary containing the projectile's starting position. returns Dict get_projectile_data() Returns null by default. returns null process_projectile(_projectile) Does nothing by default. returns null get_active_hitboxes() Returns all active hitboxes in the state. returns array _tick_before() Processing performed at the beginnnig of each tick. Does nothing by default. returns null process_feint() Returns the fallback state by default. returns string _tick_shared() Shared per_tick processing for all states. Updates things such as hitboxes, hurtboxes, current_tick counters, and movement. Returns a string if the processing detects that the state needs to be updated; otherwise, returns nothing. returns string, null process_hitboxes() Activates and deactivates hitboxes based on the current tick. returns null update_hurtbox() Updates the hurtbox based on any HurtboxState nodes available. returns null _tick_after() Processing performed at the end of each tick. Updates hitbox positions based on the object's location. returns null copy_data() Creates a copy of the state's data and returns it. returns data copy_to(state:ObjectState) Copies the current state's properties to state 's properties. returns null activate_hitbox(hitbox) Calls hitbox.activate() . returns null terminate_hitboxes() Deactivates all hitboxes in the current state. returns null deactivate_hitbox(hitbox) Does nothing by default. returns null init() Performs initial setup for the state. returns null setup_audio() Sets up required parameters for playing sound effects. returns null setup_hitboxes() Sets up parameters for hitboxes. returns null setup_hurtboxes() Sets up parameters for hurtboxes. returns null __on_hit_something(obj, _hitbox) Called when detecting the signal \"hit_something\" from an attached hitbox. Calls _on_hit_something() . returns null __on_got_parried() Called when detecting the signal \"got_parried\" from an attached hitbox. Calls _got_parried() . returns null _got_parried() Does nothing by default. returns null spawn_particle_relative(scene:PackedScene, pos = Vector2(), dir = Vector2.RIGHT) Spawns a particle effect at the listed position and direction relative to the user. returns null _enter_shared() Shared processing upon entering the state. returns null _exit_shared() Shared processing upon exiting the state. Resets the current hurtbox. returns null xy_to_dir(x, y, mul=\"1.0\", div = \"100.0\") Passthrough function for converting an X and Y value to a movement vector, with optional modifiers for speed. Returns a Dictionary containing the results. returns Dict update_sprite_frame() Updates the currently displayed sprite frame to match the current tick. returns null","title":"Methods"},{"location":"Documentation/ObjectState/#signals","text":"state_started() Emitted upon entering the state. state_ended() Emitted upon exiting the state.","title":"Signals"},{"location":"Documentation/ObjectState/#credits","text":"Info contributed by xColdxFusionx","title":"Credits"},{"location":"Documentation/ObjectState/#source","text":"ObjectState.gd extends StateInterface class_name ObjectState signal state_started () signal state_ended () export var _c_Physics = 0 export var apply_forces = false export var apply_fric = false export var apply_grav = false export var _c_Animation_and_Length = 0 export var fallback_state = \"Wait\" export var sprite_animation = \"\" export var anim_length = 1 export var sprite_anim_length = - 1 export var ticks_per_frame = 1 export var loop_animation = false export var endless = false export var _c_Static_Force = 0 export var force_dir_x = \"0.0\" export var force_dir_y = \"0.0\" export var force_speed = \"0.0\" export var force_tick = 0 export var _c_Enter_Static_Force = 0 export var enter_force_dir_x = \"0.0\" export var enter_force_dir_y = \"0.0\" export var enter_force_speed = \"0.0\" export var reset_momentum = false export var _c_Particles = 0 export ( PackedScene ) var particle_scene = null export var particle_position = Vector2 () export var spawn_particle_on_enter = false export var _c_TimedParticles = 0 export ( PackedScene ) var timed_particle_scene = null export var timed_particle_position = Vector2 () export var timed_spawn_particle_tick = 1 export var _c_Sfx = 0 export ( AudioStream ) var enter_sfx = null export var enter_sfx_volume = - 15.0 export ( AudioStream ) var sfx = null export var sfx_tick = 1 export var sfx_volume = - 15.0 export var _c_Projectiles = 0 export ( PackedScene ) var projectile_scene export var projectile_tick = 1 export var projectile_pos_x = 0 export var projectile_pos_y = 0 export var projectile_local_pos = true export var _c_Auto = 0 export var throw_positions : Dictionary = {} var enter_sfx_player var sfx_player var current_tick = - 1 var current_real_tick = - 1 var fixed var anim_name var has_hitboxes = false var current_hurtbox = null var hitbox_start_frames = { } var hurtbox_state_change_frames = { } var frame_methods = [] var max_tick = - 1 func apply_enter_force (): if enter_force_speed != \"0.0\" : var force = xy_to_dir ( enter_force_dir_x , enter_force_dir_y , enter_force_speed , \"1.0\" ) host . apply_force_relative ( force . x , force . y ) func _on_hit_something ( _obj , _hitbox ): pass func get_projectile_pos (): return { \"x\" : projectile_pos_x , \"y\" : projectile_pos_y } func get_projectile_data (): return null func process_projectile ( _projectile ): pass func get_active_hitboxes (): var hitboxes = [] for start_frame in hitbox_start_frames : var items = hitbox_start_frames [ start_frame ] for item in items : if item is Hitbox : hitboxes . append ( item ) return hitboxes func _tick_before (): pass func process_feint (): return fallback_state func _tick_shared (): if current_tick == - 1 : if spawn_particle_on_enter and particle_scene : var pos = particle_position pos . x *= host . get_facing_int () spawn_particle_relative ( particle_scene , pos , Vector2 . RIGHT * host . get_facing_int ()) apply_enter_force () current_real_tick += 1 if current_tick < anim_length or endless : current_tick += 1 process_hitboxes () update_sprite_frame () update_hurtbox () if current_tick == sfx_tick and sfx_player and not ReplayManager . resimulating : sfx_player . play () if current_tick == force_tick : if force_speed != \"0.0\" : var force = xy_to_dir ( force_dir_x , force_dir_y , force_speed , \"1.0\" ) host . apply_force_relative ( force . x , force . y ) if current_tick == projectile_tick : if projectile_scene : var pos = get_projectile_pos () var obj = host . spawn_object ( projectile_scene , pos . x , pos . y , true , get_projectile_data (), projectile_local_pos ) process_projectile ( obj ) if current_tick == timed_spawn_particle_tick : if timed_particle_scene : var pos = timed_particle_position pos . x *= host . get_facing_int () spawn_particle_relative ( timed_particle_scene , pos , Vector2 . RIGHT * host . get_facing_int ()) var new_max = false if current_tick > max_tick : max_tick = current_tick new_max = true if host . is_ghost or new_max or current_tick in frame_methods : var method_name = \"_frame_\" + str ( current_tick ) if has_method ( method_name ): if not ( current_tick in frame_methods ): frame_methods . append ( current_tick ) var next_state = call ( method_name ) if next_state != null : return next_state new_max = false if apply_fric : host . apply_fric () if apply_grav : host . apply_grav () if apply_forces : host . apply_forces () func process_hitboxes (): if hitbox_start_frames . has ( current_tick + 1 ): for hitbox in hitbox_start_frames [ current_tick + 1 ]: activate_hitbox ( hitbox ) for hitbox in get_active_hitboxes (): hitbox . facing = host . get_facing () if hitbox . active : hitbox . tick () else : deactivate_hitbox ( hitbox ) func update_hurtbox (): if current_hurtbox : current_hurtbox . tick ( host ) if current_tick in hurtbox_state_change_frames : if current_hurtbox : current_hurtbox . end ( host ) current_hurtbox = hurtbox_state_change_frames [ current_tick ] current_hurtbox . start ( host ) func _tick_after (): for hitbox in get_active_hitboxes (): var pos = host . get_pos () hitbox . update_position ( pos . x , pos . y ) func copy_data (): var d = null if data : if data is Dictionary or data is Array : d = data . duplicate () else : d = data return d func copy_to ( state : ObjectState ): var properties = get_script () . get_script_property_list () for variable in properties : var value = get ( variable . name ) if not ( value is Object or value is Array or value is Dictionary ): if value : state . set ( variable . name , value ) state . data = copy_data () state . current_real_tick = current_real_tick state . current_tick = current_real_tick func activate_hitbox ( hitbox ): hitbox . activate () func terminate_hitboxes (): for hitbox in get_active_hitboxes (): hitbox . deactivate () func deactivate_hitbox ( hitbox ): pass func init (): connect ( \"state_started\" , host , \"on_state_started\" , [ self ]) connect ( \"state_ended\" , host , \"on_state_ended\" , [ self ]) fixed = host . fixed anim_name = sprite_animation if sprite_animation else state_name if sprite_anim_length < 0 : if host . sprite . frames . has_animation ( anim_name ): sprite_anim_length = host . sprite . frames . get_frame_count ( anim_name ) else : sprite_anim_length = anim_length setup_hitboxes () setup_hurtboxes () call_deferred ( \"setup_audio\" ) func setup_audio (): if enter_sfx : enter_sfx_player = VariableSound2D . new () add_child ( enter_sfx_player ) enter_sfx_player . bus = \"Fx\" enter_sfx_player . stream = enter_sfx enter_sfx_player . volume_db = enter_sfx_volume if sfx : sfx_player = VariableSound2D . new () add_child ( sfx_player ) sfx_player . bus = \"Fx\" sfx_player . stream = sfx sfx_player . volume_db = sfx_volume func setup_hitboxes (): var hitboxes = [] for child in get_children (): if child is Hitbox : hitboxes . append ( child ) host . hitboxes . append ( child ) for hitbox in hitboxes : hitbox . init () has_hitboxes = true hitbox . host = host if hitbox . start_tick >= 0 : if hitbox_start_frames . has ( hitbox . start_tick ): hitbox_start_frames [ hitbox . start_tick ] . append ( hitbox ) else : hitbox_start_frames [ hitbox . start_tick ] = [ hitbox ] hitbox . connect ( \"hit_something\" , self , \"__on_hit_something\" ) hitbox . connect ( \"got_parried\" , self , \"__on_got_parried\" ) for hitbox2 in hitboxes : if hitbox2 . group == hitbox . group : hitbox . grouped_hitboxes . append ( hitbox2 ) func setup_hurtboxes (): for child in get_children (): if child is HurtboxState : hurtbox_state_change_frames [ child . start_tick ] = child func __on_hit_something ( obj , hitbox ): if active : _on_hit_something ( obj , hitbox ) func __on_got_parried (): if active : _got_parried () func _got_parried (): pass func spawn_particle_relative ( scene : PackedScene , pos = Vector2 (), dir = Vector2 . RIGHT ): var p = host . get_pos_visual () host . spawn_particle_effect ( scene , p + pos , dir ) func _enter_shared (): if reset_momentum : host . reset_momentum () current_tick = - 1 current_real_tick = - 1 if enter_sfx_player and not ReplayManager . resimulating : enter_sfx_player . play () emit_signal ( \"state_started\" ) func _exit_shared (): if current_hurtbox : current_hurtbox . end ( host ) host . reset_hurtbox () func xy_to_dir ( x , y , mul = \"1.0\" , div = \"100.0\" ): return host . xy_to_dir ( x , y , mul , div ) func update_sprite_frame (): if ReplayManager . resimulating : return if not host . sprite . frames . has_animation ( anim_name ): return if host . sprite . animation != anim_name : host . sprite . animation = anim_name host . sprite . frame = 0 var sprite_tick = current_tick / ticks_per_frame var frame = ( sprite_tick % sprite_anim_length ) if loop_animation else Utils . int_min ( sprite_tick , sprite_anim_length ) host . sprite . frame = frame","title":"Source"},{"location":"Miscellaneous/StyleGuide/","text":".spacer { padding-top: 10px; padding-bottom: 25px; } .nowrap { overflow: hidden; white-space: nowrap; } Preface This page serves as both a template and as an example for how each type of document on YOMIDoku is structured. Classes / GDscript Files In: res://(Filepath) Inherits: (Inheritance Chain) Description A brief description of the class / GDscript file. Properties Each publicly accessible variable, alongside a brief description, data type, and initial value if applicable, in the following format: Property Default Value Description EXAMPLE_PROPERTY 123 A property, with a default value. EXAMPLE_PROPERTY_TEXT \"Example text!\" A property with a string. EXAMPLE_PROPERTY_DICT {Key1: \"Value\",Key2: 123} A property with a dictionary. EXAMPLE_PROPERTY_UNINIT N/A A property, without a default value. If there are no publicly accessible variables, then display: There are no properties for this class. Enumerations A list of each enumerated type, alongside a brief description in the following format: enum Example EXAMPLE_ENUM1 = 0 --- A brief description of the first enum. EXAMPLE_ENUM2 = 1 --- A brief description of the second enum. EXAMPLE_ENUM3 = 2 --- A brief description of the third enum. If there are no enums, then display: There are no enumerated types for this class. Constants A list of constants, alongside a brief description and their values in the following format: Constant Value Description MAX_STALES 15 N/A MIN_STALE_MODIFIER \"0.2\" N/A If there are no constants, then display: There are no constants for this class. Methods A list of methods, alongside a brief description, the return type, arguments (with data types), in the following format: exampleFunctionReturnsNull() A description of the function goes here. If you do not know how to describe the function, then display N/A. This function returns null; dont list return types in the description, this is just for clarification in the style guide. returns null exampleFunctionReturnsInt(arg1) This is a function that returns an int. It also has an argument. returns int exampleFunctionReturnsDict(arg1:int,arg2=\"Default\") This is a function that returns a dictionary value. It also has a type specified argument, and an argument with a default value. returns dict If there are no methods, then display: There are no methods for this class. Signals A list of signals, alongside a brief description and the signal arguments in the following format: example_signal() A description of the signal goes here. example_signal_with_arguments(arg1, arg2, arg3) This signal emits several arguments. If there are no signals, then display: There are no signals for this class. Credits Attribute any contributors here, using a hyperlink to their name on the about page; do NOT remove contributors. Source A fenced codeblock, under an admonition in the following format: ExampleSource.gd Source code goes here !","title":"Style Guide"},{"location":"Miscellaneous/StyleGuide/#preface","text":"This page serves as both a template and as an example for how each type of document on YOMIDoku is structured.","title":"Preface"},{"location":"Miscellaneous/StyleGuide/#classes-gdscript-files","text":"In: res://(Filepath) Inherits: (Inheritance Chain)","title":"Classes / GDscript Files"},{"location":"Miscellaneous/StyleGuide/#description","text":"A brief description of the class / GDscript file.","title":"Description"},{"location":"Miscellaneous/StyleGuide/#properties","text":"Each publicly accessible variable, alongside a brief description, data type, and initial value if applicable, in the following format: Property Default Value Description EXAMPLE_PROPERTY 123 A property, with a default value. EXAMPLE_PROPERTY_TEXT \"Example text!\" A property with a string. EXAMPLE_PROPERTY_DICT {Key1: \"Value\",Key2: 123} A property with a dictionary. EXAMPLE_PROPERTY_UNINIT N/A A property, without a default value. If there are no publicly accessible variables, then display: There are no properties for this class.","title":"Properties"},{"location":"Miscellaneous/StyleGuide/#enumerations","text":"A list of each enumerated type, alongside a brief description in the following format: enum Example EXAMPLE_ENUM1 = 0 --- A brief description of the first enum. EXAMPLE_ENUM2 = 1 --- A brief description of the second enum. EXAMPLE_ENUM3 = 2 --- A brief description of the third enum. If there are no enums, then display: There are no enumerated types for this class.","title":"Enumerations"},{"location":"Miscellaneous/StyleGuide/#constants","text":"A list of constants, alongside a brief description and their values in the following format: Constant Value Description MAX_STALES 15 N/A MIN_STALE_MODIFIER \"0.2\" N/A If there are no constants, then display: There are no constants for this class.","title":"Constants"},{"location":"Miscellaneous/StyleGuide/#methods","text":"A list of methods, alongside a brief description, the return type, arguments (with data types), in the following format: exampleFunctionReturnsNull() A description of the function goes here. If you do not know how to describe the function, then display N/A. This function returns null; dont list return types in the description, this is just for clarification in the style guide. returns null exampleFunctionReturnsInt(arg1) This is a function that returns an int. It also has an argument. returns int exampleFunctionReturnsDict(arg1:int,arg2=\"Default\") This is a function that returns a dictionary value. It also has a type specified argument, and an argument with a default value. returns dict If there are no methods, then display: There are no methods for this class.","title":"Methods"},{"location":"Miscellaneous/StyleGuide/#signals","text":"A list of signals, alongside a brief description and the signal arguments in the following format: example_signal() A description of the signal goes here. example_signal_with_arguments(arg1, arg2, arg3) This signal emits several arguments. If there are no signals, then display: There are no signals for this class.","title":"Signals"},{"location":"Miscellaneous/StyleGuide/#credits","text":"Attribute any contributors here, using a hyperlink to their name on the about page; do NOT remove contributors.","title":"Credits"},{"location":"Miscellaneous/StyleGuide/#source","text":"A fenced codeblock, under an admonition in the following format: ExampleSource.gd Source code goes here !","title":"Source"}]}